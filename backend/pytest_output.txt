
tests/api/api_v1/test_auth.py::test_signup [31mFAILED[0m[31m                        [  3%][0m
tests/api/api_v1/test_auth.py::test_verification_email [31mFAILED[0m[31m            [  6%][0m
tests/api/api_v1/test_auth.py::test_web_session_authentication [31mFAILED[0m[31m    [  9%][0m
tests/api/api_v1/test_auth.py::test_web_session_authentication_fail [32mPASSED[0m[31m [ 12%][0m
tests/api/api_v1/test_auth.py::test_send_reset_email [31mFAILED[0m[31m              [ 16%][0m
tests/api/api_v1/test_auth.py::test_reset_password [31mFAILED[0m[31m                [ 19%][0m
tests/api/api_v1/test_auth.py::test_login_with_old_password [32mPASSED[0m[31m       [ 22%][0m
tests/api/api_v1/test_auth.py::test_login_with_new_password [31mFAILED[0m[31m       [ 25%][0m
tests/api/api_v1/test_auth.py::test_change_password [31mFAILED[0m[31m               [ 29%][0m
tests/api/api_v1/test_auth.py::test_logout [31mFAILED[0m[31m                        [ 32%][0m
tests/api/api_v1/test_auth.py::test_delete_user [31mFAILED[0m[31m                   [ 35%][0m
tests/api/api_v1/test_course.py::test_post_course [32mPASSED[0m[31m                 [ 38%][0m
tests/api/api_v1/test_course.py::test_get_course [32mPASSED[0m[31m                  [ 41%][0m
tests/api/api_v1/test_course.py::test_get_specific_course [32mPASSED[0m[31m         [ 45%][0m
tests/api/api_v1/test_course.py::test_put_specific_course [32mPASSED[0m[31m         [ 48%][0m
tests/api/api_v1/test_course.py::test_delete_course [32mPASSED[0m[31m               [ 51%][0m
tests/api/api_v1/test_department.py::test_post_department [32mPASSED[0m[31m         [ 54%][0m
tests/api/api_v1/test_department.py::test_get_department [32mPASSED[0m[31m          [ 58%][0m
tests/api/api_v1/test_department.py::test_get_specific_department [32mPASSED[0m[31m [ 61%][0m
tests/api/api_v1/test_department.py::test_put_specific_department [32mPASSED[0m[31m [ 64%][0m
tests/api/api_v1/test_department.py::test_delete_department [32mPASSED[0m[31m       [ 67%][0m
tests/api/api_v1/test_program.py::test_post_program [32mPASSED[0m[31m               [ 70%][0m
tests/api/api_v1/test_program.py::test_get_program [32mPASSED[0m[31m                [ 74%][0m
tests/api/api_v1/test_program.py::test_get_specific_program [32mPASSED[0m[31m       [ 77%][0m
tests/api/api_v1/test_program.py::test_put_specific_program [32mPASSED[0m[31m       [ 80%][0m
tests/api/api_v1/test_program.py::test_delete_program [32mPASSED[0m[31m             [ 83%][0m
tests/api/api_v1/test_school.py::test_post_school [32mPASSED[0m[31m                 [ 87%][0m
tests/api/api_v1/test_school.py::test_get_school [32mPASSED[0m[31m                  [ 90%][0m
tests/api/api_v1/test_school.py::test_get_specific_school [32mPASSED[0m[31m         [ 93%][0m
tests/api/api_v1/test_school.py::test_put_specific_school [32mPASSED[0m[31m         [ 96%][0m
tests/api/api_v1/test_school.py::test_delete_school [32mPASSED[0m[31m               [100%][0m

=================================== FAILURES ===================================
[31m[1m_________________________________ test_signup __________________________________[0m

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5690>

    [94mdef[39;49;00m [92m_new_conn[39;49;00m([96mself[39;49;00m):
    [90m    [39;49;00m[33m"""Establish a socket connection and set nodelay settings on it.[39;49;00m
    [33m[39;49;00m
    [33m    :return: New socket connection.[39;49;00m
    [33m    """[39;49;00m
        extra_kw = {}
        [94mif[39;49;00m [96mself[39;49;00m.source_address:
            extra_kw[[33m"[39;49;00m[33msource_address[39;49;00m[33m"[39;49;00m] = [96mself[39;49;00m.source_address
    
        [94mif[39;49;00m [96mself[39;49;00m.socket_options:
            extra_kw[[33m"[39;49;00m[33msocket_options[39;49;00m[33m"[39;49;00m] = [96mself[39;49;00m.socket_options
    
        [94mtry[39;49;00m:
>           conn = connection.create_connection(
                ([96mself[39;49;00m._dns_host, [96mself[39;49;00m.port), [96mself[39;49;00m.timeout, **extra_kw
            )

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connection.py[0m:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 8025), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    [94mdef[39;49;00m [92mcreate_connection[39;49;00m(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=[94mNone[39;49;00m,
        socket_options=[94mNone[39;49;00m,
    ):
    [90m    [39;49;00m[33m"""Connect to *address* and return the socket object.[39;49;00m
    [33m[39;49;00m
    [33m    Convenience function.  Connect to *address* (a 2-tuple ``(host,[39;49;00m
    [33m    port)``) and return the socket object.  Passing the optional[39;49;00m
    [33m    *timeout* parameter will set the timeout on the socket instance[39;49;00m
    [33m    before attempting to connect.  If no *timeout* is supplied, the[39;49;00m
    [33m    global default timeout setting returned by :func:`socket.getdefaulttimeout`[39;49;00m
    [33m    is used.  If *source_address* is set it must be a tuple of (host, port)[39;49;00m
    [33m    for the socket to bind as a source address before making the connection.[39;49;00m
    [33m    An host of '' or port 0 tells the OS to use the default.[39;49;00m
    [33m    """[39;49;00m
    
        host, port = address
        [94mif[39;49;00m host.startswith([33m"[39;49;00m[33m[[39;49;00m[33m"[39;49;00m):
            host = host.strip([33m"[39;49;00m[33m[][39;49;00m[33m"[39;49;00m)
        err = [94mNone[39;49;00m
    
        [90m# Using the value from allowed_gai_family() in the context of getaddrinfo lets[39;49;00m
        [90m# us select whether to work with IPv4 DNS records, IPv6 records, or both.[39;49;00m
        [90m# The original create_connection function always returns all records.[39;49;00m
        family = allowed_gai_family()
    
        [94mtry[39;49;00m:
            host.encode([33m"[39;49;00m[33midna[39;49;00m[33m"[39;49;00m)
        [94mexcept[39;49;00m [96mUnicodeError[39;49;00m:
            [94mreturn[39;49;00m six.raise_from(
                LocationParseError([33mu[39;49;00m[33m"[39;49;00m[33m'[39;49;00m[33m%s[39;49;00m[33m'[39;49;00m[33m, label empty or too long[39;49;00m[33m"[39;49;00m % host), [94mNone[39;49;00m
            )
    
        [94mfor[39;49;00m res [95min[39;49;00m socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = [94mNone[39;49;00m
            [94mtry[39;49;00m:
                sock = socket.socket(af, socktype, proto)
    
                [90m# If provided, set socket level options before connecting.[39;49;00m
                _set_socket_options(sock, socket_options)
    
                [94mif[39;49;00m timeout [95mis[39;49;00m [95mnot[39;49;00m socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                [94mif[39;49;00m source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                [94mreturn[39;49;00m sock
    
            [94mexcept[39;49;00m socket.error [94mas[39;49;00m e:
                err = e
                [94mif[39;49;00m sock [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                    sock.close()
                    sock = [94mNone[39;49;00m
    
        [94mif[39;49;00m err [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
>           [94mraise[39;49;00m err

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/util/connection.py[0m:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 8025), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    [94mdef[39;49;00m [92mcreate_connection[39;49;00m(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=[94mNone[39;49;00m,
        socket_options=[94mNone[39;49;00m,
    ):
    [90m    [39;49;00m[33m"""Connect to *address* and return the socket object.[39;49;00m
    [33m[39;49;00m
    [33m    Convenience function.  Connect to *address* (a 2-tuple ``(host,[39;49;00m
    [33m    port)``) and return the socket object.  Passing the optional[39;49;00m
    [33m    *timeout* parameter will set the timeout on the socket instance[39;49;00m
    [33m    before attempting to connect.  If no *timeout* is supplied, the[39;49;00m
    [33m    global default timeout setting returned by :func:`socket.getdefaulttimeout`[39;49;00m
    [33m    is used.  If *source_address* is set it must be a tuple of (host, port)[39;49;00m
    [33m    for the socket to bind as a source address before making the connection.[39;49;00m
    [33m    An host of '' or port 0 tells the OS to use the default.[39;49;00m
    [33m    """[39;49;00m
    
        host, port = address
        [94mif[39;49;00m host.startswith([33m"[39;49;00m[33m[[39;49;00m[33m"[39;49;00m):
            host = host.strip([33m"[39;49;00m[33m[][39;49;00m[33m"[39;49;00m)
        err = [94mNone[39;49;00m
    
        [90m# Using the value from allowed_gai_family() in the context of getaddrinfo lets[39;49;00m
        [90m# us select whether to work with IPv4 DNS records, IPv6 records, or both.[39;49;00m
        [90m# The original create_connection function always returns all records.[39;49;00m
        family = allowed_gai_family()
    
        [94mtry[39;49;00m:
            host.encode([33m"[39;49;00m[33midna[39;49;00m[33m"[39;49;00m)
        [94mexcept[39;49;00m [96mUnicodeError[39;49;00m:
            [94mreturn[39;49;00m six.raise_from(
                LocationParseError([33mu[39;49;00m[33m"[39;49;00m[33m'[39;49;00m[33m%s[39;49;00m[33m'[39;49;00m[33m, label empty or too long[39;49;00m[33m"[39;49;00m % host), [94mNone[39;49;00m
            )
    
        [94mfor[39;49;00m res [95min[39;49;00m socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = [94mNone[39;49;00m
            [94mtry[39;49;00m:
                sock = socket.socket(af, socktype, proto)
    
                [90m# If provided, set socket level options before connecting.[39;49;00m
                _set_socket_options(sock, socket_options)
    
                [94mif[39;49;00m timeout [95mis[39;49;00m [95mnot[39;49;00m socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                [94mif[39;49;00m source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
[1m[31mE               ConnectionRefusedError: [Errno 111] Connection refused[0m

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/util/connection.py[0m:85: ConnectionRefusedError

[33mDuring handling of the above exception, another exception occurred:[0m

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fd1564632e0>
method = 'DELETE', url = '/api/v1/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/messages', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    [94mdef[39;49;00m [92murlopen[39;49;00m(
        [96mself[39;49;00m,
        method,
        url,
        body=[94mNone[39;49;00m,
        headers=[94mNone[39;49;00m,
        retries=[94mNone[39;49;00m,
        redirect=[94mTrue[39;49;00m,
        assert_same_host=[94mTrue[39;49;00m,
        timeout=_Default,
        pool_timeout=[94mNone[39;49;00m,
        release_conn=[94mNone[39;49;00m,
        chunked=[94mFalse[39;49;00m,
        body_pos=[94mNone[39;49;00m,
        **response_kw
    ):
    [90m    [39;49;00m[33m"""[39;49;00m
    [33m    Get a connection from the pool and perform an HTTP request. This is the[39;49;00m
    [33m    lowest level call for making a request, so you'll need to specify all[39;49;00m
    [33m    the raw details.[39;49;00m
    [33m[39;49;00m
    [33m    .. note::[39;49;00m
    [33m[39;49;00m
    [33m       More commonly, it's appropriate to use a convenience method provided[39;49;00m
    [33m       by :class:`.RequestMethods`, such as :meth:`request`.[39;49;00m
    [33m[39;49;00m
    [33m    .. note::[39;49;00m
    [33m[39;49;00m
    [33m       `release_conn` will only behave as expected if[39;49;00m
    [33m       `preload_content=False` because we want to make[39;49;00m
    [33m       `preload_content=False` the default behaviour someday soon without[39;49;00m
    [33m       breaking backwards compatibility.[39;49;00m
    [33m[39;49;00m
    [33m    :param method:[39;49;00m
    [33m        HTTP request method (such as GET, POST, PUT, etc.)[39;49;00m
    [33m[39;49;00m
    [33m    :param url:[39;49;00m
    [33m        The URL to perform the request on.[39;49;00m
    [33m[39;49;00m
    [33m    :param body:[39;49;00m
    [33m        Data to send in the request body, either :class:`str`, :class:`bytes`,[39;49;00m
    [33m        an iterable of :class:`str`/:class:`bytes`, or a file-like object.[39;49;00m
    [33m[39;49;00m
    [33m    :param headers:[39;49;00m
    [33m        Dictionary of custom headers to send, such as User-Agent,[39;49;00m
    [33m        If-None-Match, etc. If None, pool headers are used. If provided,[39;49;00m
    [33m        these headers completely replace any pool-specific headers.[39;49;00m
    [33m[39;49;00m
    [33m    :param retries:[39;49;00m
    [33m        Configure the number of retries to allow before raising a[39;49;00m
    [33m        :class:`~urllib3.exceptions.MaxRetryError` exception.[39;49;00m
    [33m[39;49;00m
    [33m        Pass ``None`` to retry until you receive a response. Pass a[39;49;00m
    [33m        :class:`~urllib3.util.retry.Retry` object for fine-grained control[39;49;00m
    [33m        over different types of retries.[39;49;00m
    [33m        Pass an integer number to retry connection errors that many times,[39;49;00m
    [33m        but no other types of errors. Pass zero to never retry.[39;49;00m
    [33m[39;49;00m
    [33m        If ``False``, then retries are disabled and any exception is raised[39;49;00m
    [33m        immediately. Also, instead of raising a MaxRetryError on redirects,[39;49;00m
    [33m        the redirect response will be returned.[39;49;00m
    [33m[39;49;00m
    [33m    :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.[39;49;00m
    [33m[39;49;00m
    [33m    :param redirect:[39;49;00m
    [33m        If True, automatically handle redirects (status codes 301, 302,[39;49;00m
    [33m        303, 307, 308). Each redirect counts as a retry. Disabling retries[39;49;00m
    [33m        will disable redirect, too.[39;49;00m
    [33m[39;49;00m
    [33m    :param assert_same_host:[39;49;00m
    [33m        If ``True``, will make sure that the host of the pool requests is[39;49;00m
    [33m        consistent else will raise HostChangedError. When ``False``, you can[39;49;00m
    [33m        use the pool on an HTTP proxy and request foreign hosts.[39;49;00m
    [33m[39;49;00m
    [33m    :param timeout:[39;49;00m
    [33m        If specified, overrides the default timeout for this one[39;49;00m
    [33m        request. It may be a float (in seconds) or an instance of[39;49;00m
    [33m        :class:`urllib3.util.Timeout`.[39;49;00m
    [33m[39;49;00m
    [33m    :param pool_timeout:[39;49;00m
    [33m        If set and the pool is set to block=True, then this method will[39;49;00m
    [33m        block for ``pool_timeout`` seconds and raise EmptyPoolError if no[39;49;00m
    [33m        connection is available within the time period.[39;49;00m
    [33m[39;49;00m
    [33m    :param release_conn:[39;49;00m
    [33m        If False, then the urlopen call will not release the connection[39;49;00m
    [33m        back into the pool once a response is received (but will release if[39;49;00m
    [33m        you read the entire contents of the response such as when[39;49;00m
    [33m        `preload_content=True`). This is useful if you're not preloading[39;49;00m
    [33m        the response's content immediately. You will need to call[39;49;00m
    [33m        ``r.release_conn()`` on the response ``r`` to return the connection[39;49;00m
    [33m        back into the pool. If None, it takes the value of[39;49;00m
    [33m        ``response_kw.get('preload_content', True)``.[39;49;00m
    [33m[39;49;00m
    [33m    :param chunked:[39;49;00m
    [33m        If True, urllib3 will send the body using chunked transfer[39;49;00m
    [33m        encoding. Otherwise, urllib3 will send the body using the standard[39;49;00m
    [33m        content-length form. Defaults to False.[39;49;00m
    [33m[39;49;00m
    [33m    :param int body_pos:[39;49;00m
    [33m        Position to seek to in file-like body in the event of a retry or[39;49;00m
    [33m        redirect. Typically this won't need to be set because urllib3 will[39;49;00m
    [33m        auto-populate the value when needed.[39;49;00m
    [33m[39;49;00m
    [33m    :param \\**response_kw:[39;49;00m
    [33m        Additional parameters are passed to[39;49;00m
    [33m        :meth:`urllib3.response.HTTPResponse.from_httplib`[39;49;00m
    [33m    """[39;49;00m
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        [94mif[39;49;00m headers [95mis[39;49;00m [94mNone[39;49;00m:
            headers = [96mself[39;49;00m.headers
    
        [94mif[39;49;00m [95mnot[39;49;00m [96misinstance[39;49;00m(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=[96mself[39;49;00m.retries)
    
        [94mif[39;49;00m release_conn [95mis[39;49;00m [94mNone[39;49;00m:
            release_conn = response_kw.get([33m"[39;49;00m[33mpreload_content[39;49;00m[33m"[39;49;00m, [94mTrue[39;49;00m)
    
        [90m# Check host[39;49;00m
        [94mif[39;49;00m assert_same_host [95mand[39;49;00m [95mnot[39;49;00m [96mself[39;49;00m.is_same_host(url):
            [94mraise[39;49;00m HostChangedError([96mself[39;49;00m, url, retries)
    
        [90m# Ensure that the URL we're connecting to is properly encoded[39;49;00m
        [94mif[39;49;00m url.startswith([33m"[39;49;00m[33m/[39;49;00m[33m"[39;49;00m):
            url = six.ensure_str(_encode_target(url))
        [94melse[39;49;00m:
            url = six.ensure_str(parsed_url.url)
    
        conn = [94mNone[39;49;00m
    
        [90m# Track whether `conn` needs to be released before[39;49;00m
        [90m# returning/raising/recursing. Update this variable if necessary, and[39;49;00m
        [90m# leave `release_conn` constant throughout the function. That way, if[39;49;00m
        [90m# the function recurses, the original value of `release_conn` will be[39;49;00m
        [90m# passed down into the recursive call, and its value will be respected.[39;49;00m
        [90m#[39;49;00m
        [90m# See issue #651 [1] for details.[39;49;00m
        [90m#[39;49;00m
        [90m# [1] <https://github.com/urllib3/urllib3/issues/651>[39;49;00m
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            [96mself[39;49;00m.proxy, [96mself[39;49;00m.proxy_config, destination_scheme
        )
    
        [90m# Merge the proxy headers. Only done when not using HTTP CONNECT. We[39;49;00m
        [90m# have to copy the headers dict so we can safely change it without those[39;49;00m
        [90m# changes being reflected in anyone else's copy.[39;49;00m
        [94mif[39;49;00m [95mnot[39;49;00m http_tunnel_required:
            headers = headers.copy()
            headers.update([96mself[39;49;00m.proxy_headers)
    
        [90m# Must keep the exception bound to a separate variable or else Python 3[39;49;00m
        [90m# complains about UnboundLocalError.[39;49;00m
        err = [94mNone[39;49;00m
    
        [90m# Keep track of whether we cleanly exited the except block. This[39;49;00m
        [90m# ensures we do proper cleanup in finally.[39;49;00m
        clean_exit = [94mFalse[39;49;00m
    
        [90m# Rewind body position, if needed. Record current position[39;49;00m
        [90m# for future rewinds in the event of a redirect/retry.[39;49;00m
        body_pos = set_file_position(body, body_pos)
    
        [94mtry[39;49;00m:
            [90m# Request a connection from the queue.[39;49;00m
            timeout_obj = [96mself[39;49;00m._get_timeout(timeout)
            conn = [96mself[39;49;00m._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = [96mself[39;49;00m.proxy [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m [95mand[39;49;00m [95mnot[39;49;00m [96mgetattr[39;49;00m(
                conn, [33m"[39;49;00m[33msock[39;49;00m[33m"[39;49;00m, [94mNone[39;49;00m
            )
            [94mif[39;49;00m is_new_proxy_conn [95mand[39;49;00m http_tunnel_required:
                [96mself[39;49;00m._prepare_proxy(conn)
    
            [90m# Make the request on the httplib connection object.[39;49;00m
>           httplib_response = [96mself[39;49;00m._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connectionpool.py[0m:703: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fd1564632e0>
conn = <urllib3.connection.HTTPConnection object at 0x7fd1509f5690>
method = 'DELETE', url = '/api/v1/messages'
timeout = Timeout(connect=None, read=None, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=None, read=None, total=None)

    [94mdef[39;49;00m [92m_make_request[39;49;00m(
        [96mself[39;49;00m, conn, method, url, timeout=_Default, chunked=[94mFalse[39;49;00m, **httplib_request_kw
    ):
    [90m    [39;49;00m[33m"""[39;49;00m
    [33m    Perform a request on a given urllib connection object taken from our[39;49;00m
    [33m    pool.[39;49;00m
    [33m[39;49;00m
    [33m    :param conn:[39;49;00m
    [33m        a connection from one of our connection pools[39;49;00m
    [33m[39;49;00m
    [33m    :param timeout:[39;49;00m
    [33m        Socket timeout in seconds for the request. This can be a[39;49;00m
    [33m        float or integer, which will set the same timeout value for[39;49;00m
    [33m        the socket connect and the socket read, or an instance of[39;49;00m
    [33m        :class:`urllib3.util.Timeout`, which gives you more fine-grained[39;49;00m
    [33m        control over your timeouts.[39;49;00m
    [33m    """[39;49;00m
        [96mself[39;49;00m.num_requests += [94m1[39;49;00m
    
        timeout_obj = [96mself[39;49;00m._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        [90m# Trigger any extra validation we need to do.[39;49;00m
        [94mtry[39;49;00m:
            [96mself[39;49;00m._validate_conn(conn)
        [94mexcept[39;49;00m (SocketTimeout, BaseSSLError) [94mas[39;49;00m e:
            [90m# Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.[39;49;00m
            [96mself[39;49;00m._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            [94mraise[39;49;00m
    
        [90m# conn.request() calls http.client.*.request, not the method in[39;49;00m
        [90m# urllib3.request. It also calls makefile (recv) on the socket.[39;49;00m
        [94mtry[39;49;00m:
            [94mif[39;49;00m chunked:
                conn.request_chunked(method, url, **httplib_request_kw)
            [94melse[39;49;00m:
>               conn.request(method, url, **httplib_request_kw)

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connectionpool.py[0m:398: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5690>
method = 'DELETE', url = '/api/v1/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    [94mdef[39;49;00m [92mrequest[39;49;00m([96mself[39;49;00m, method, url, body=[94mNone[39;49;00m, headers=[94mNone[39;49;00m):
        [94mif[39;49;00m headers [95mis[39;49;00m [94mNone[39;49;00m:
            headers = {}
        [94melse[39;49;00m:
            [90m# Avoid modifying the headers passed into .request()[39;49;00m
            headers = headers.copy()
        [94mif[39;49;00m [33m"[39;49;00m[33muser-agent[39;49;00m[33m"[39;49;00m [95mnot[39;49;00m [95min[39;49;00m (six.ensure_str(k.lower()) [94mfor[39;49;00m k [95min[39;49;00m headers):
            headers[[33m"[39;49;00m[33mUser-Agent[39;49;00m[33m"[39;49;00m] = _get_default_user_agent()
>       [96msuper[39;49;00m(HTTPConnection, [96mself[39;49;00m).request(method, url, body=body, headers=headers)

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connection.py[0m:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5690>
method = 'DELETE', url = '/api/v1/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    [94mdef[39;49;00m [92mrequest[39;49;00m([96mself[39;49;00m, method, url, body=[94mNone[39;49;00m, headers={}, *,
                encode_chunked=[94mFalse[39;49;00m):
    [90m    [39;49;00m[33m"""Send a complete request to the server."""[39;49;00m
>       [96mself[39;49;00m._send_request(method, url, body, headers, encode_chunked)

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:1282: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5690>
method = 'DELETE', url = '/api/v1/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
encode_chunked = False

    [94mdef[39;49;00m [92m_send_request[39;49;00m([96mself[39;49;00m, method, url, body, headers, encode_chunked):
        [90m# Honor explicitly requested Host: and Accept-Encoding: headers.[39;49;00m
        header_names = [96mfrozenset[39;49;00m(k.lower() [94mfor[39;49;00m k [95min[39;49;00m headers)
        skips = {}
        [94mif[39;49;00m [33m'[39;49;00m[33mhost[39;49;00m[33m'[39;49;00m [95min[39;49;00m header_names:
            skips[[33m'[39;49;00m[33mskip_host[39;49;00m[33m'[39;49;00m] = [94m1[39;49;00m
        [94mif[39;49;00m [33m'[39;49;00m[33maccept-encoding[39;49;00m[33m'[39;49;00m [95min[39;49;00m header_names:
            skips[[33m'[39;49;00m[33mskip_accept_encoding[39;49;00m[33m'[39;49;00m] = [94m1[39;49;00m
    
        [96mself[39;49;00m.putrequest(method, url, **skips)
    
        [90m# chunked encoding will happen if HTTP/1.1 is used and either[39;49;00m
        [90m# the caller passes encode_chunked=True or the following[39;49;00m
        [90m# conditions hold:[39;49;00m
        [90m# 1. content-length has not been explicitly set[39;49;00m
        [90m# 2. the body is a file or iterable, but not a str or bytes-like[39;49;00m
        [90m# 3. Transfer-Encoding has NOT been explicitly set by the caller[39;49;00m
    
        [94mif[39;49;00m [33m'[39;49;00m[33mcontent-length[39;49;00m[33m'[39;49;00m [95mnot[39;49;00m [95min[39;49;00m header_names:
            [90m# only chunk body if not explicitly set for backwards[39;49;00m
            [90m# compatibility, assuming the client code is already handling the[39;49;00m
            [90m# chunking[39;49;00m
            [94mif[39;49;00m [33m'[39;49;00m[33mtransfer-encoding[39;49;00m[33m'[39;49;00m [95mnot[39;49;00m [95min[39;49;00m header_names:
                [90m# if content-length cannot be automatically determined, fall[39;49;00m
                [90m# back to chunked encoding[39;49;00m
                encode_chunked = [94mFalse[39;49;00m
                content_length = [96mself[39;49;00m._get_content_length(body, method)
                [94mif[39;49;00m content_length [95mis[39;49;00m [94mNone[39;49;00m:
                    [94mif[39;49;00m body [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                        [94mif[39;49;00m [96mself[39;49;00m.debuglevel > [94m0[39;49;00m:
                            [96mprint[39;49;00m([33m'[39;49;00m[33mUnable to determine size of [39;49;00m[33m%r[39;49;00m[33m'[39;49;00m % body)
                        encode_chunked = [94mTrue[39;49;00m
                        [96mself[39;49;00m.putheader([33m'[39;49;00m[33mTransfer-Encoding[39;49;00m[33m'[39;49;00m, [33m'[39;49;00m[33mchunked[39;49;00m[33m'[39;49;00m)
                [94melse[39;49;00m:
                    [96mself[39;49;00m.putheader([33m'[39;49;00m[33mContent-Length[39;49;00m[33m'[39;49;00m, [96mstr[39;49;00m(content_length))
        [94melse[39;49;00m:
            encode_chunked = [94mFalse[39;49;00m
    
        [94mfor[39;49;00m hdr, value [95min[39;49;00m headers.items():
            [96mself[39;49;00m.putheader(hdr, value)
        [94mif[39;49;00m [96misinstance[39;49;00m(body, [96mstr[39;49;00m):
            [90m# RFC 2616 Section 3.7.1 says that text default has a[39;49;00m
            [90m# default charset of iso-8859-1.[39;49;00m
            body = _encode(body, [33m'[39;49;00m[33mbody[39;49;00m[33m'[39;49;00m)
>       [96mself[39;49;00m.endheaders(body, encode_chunked=encode_chunked)

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:1328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5690>
message_body = None

    [94mdef[39;49;00m [92mendheaders[39;49;00m([96mself[39;49;00m, message_body=[94mNone[39;49;00m, *, encode_chunked=[94mFalse[39;49;00m):
    [90m    [39;49;00m[33m"""Indicate that the last header line has been sent to the server.[39;49;00m
    [33m[39;49;00m
    [33m    This method sends the request to the server.  The optional message_body[39;49;00m
    [33m    argument can be used to pass a message body associated with the[39;49;00m
    [33m    request.[39;49;00m
    [33m    """[39;49;00m
        [94mif[39;49;00m [96mself[39;49;00m.__state == _CS_REQ_STARTED:
            [96mself[39;49;00m.__state = _CS_REQ_SENT
        [94melse[39;49;00m:
            [94mraise[39;49;00m CannotSendHeader()
>       [96mself[39;49;00m._send_output(message_body, encode_chunked=encode_chunked)

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:1277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5690>
message_body = None, encode_chunked = False

    [94mdef[39;49;00m [92m_send_output[39;49;00m([96mself[39;49;00m, message_body=[94mNone[39;49;00m, encode_chunked=[94mFalse[39;49;00m):
    [90m    [39;49;00m[33m"""Send the currently buffered request and clear the buffer.[39;49;00m
    [33m[39;49;00m
    [33m    Appends an extra \\r\\n to the buffer.[39;49;00m
    [33m    A message_body may be specified, to be appended to the request.[39;49;00m
    [33m    """[39;49;00m
        [96mself[39;49;00m._buffer.extend(([33mb[39;49;00m[33m"[39;49;00m[33m"[39;49;00m, [33mb[39;49;00m[33m"[39;49;00m[33m"[39;49;00m))
        msg = [33mb[39;49;00m[33m"[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m"[39;49;00m.join([96mself[39;49;00m._buffer)
        [94mdel[39;49;00m [96mself[39;49;00m._buffer[:]
>       [96mself[39;49;00m.send(msg)

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:1037: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5690>
data = b'DELETE /api/v1/messages HTTP/1.1\r\nHost: localhost:8025\r\nUser-Agent: python-requests/2.27.1\r\nAccept-Encoding: gzip, deflate\r\nAccept: */*\r\nConnection: keep-alive\r\nContent-Length: 0\r\n\r\n'

    [94mdef[39;49;00m [92msend[39;49;00m([96mself[39;49;00m, data):
    [90m    [39;49;00m[33m"""Send `data' to the server.[39;49;00m
    [33m    ``data`` can be a string object, a bytes object, an array object, a[39;49;00m
    [33m    file-like object that supports a .read() method, or an iterable object.[39;49;00m
    [33m    """[39;49;00m
    
        [94mif[39;49;00m [96mself[39;49;00m.sock [95mis[39;49;00m [94mNone[39;49;00m:
            [94mif[39;49;00m [96mself[39;49;00m.auto_open:
>               [96mself[39;49;00m.connect()

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5690>

    [94mdef[39;49;00m [92mconnect[39;49;00m([96mself[39;49;00m):
>       conn = [96mself[39;49;00m._new_conn()

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connection.py[0m:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5690>

    [94mdef[39;49;00m [92m_new_conn[39;49;00m([96mself[39;49;00m):
    [90m    [39;49;00m[33m"""Establish a socket connection and set nodelay settings on it.[39;49;00m
    [33m[39;49;00m
    [33m    :return: New socket connection.[39;49;00m
    [33m    """[39;49;00m
        extra_kw = {}
        [94mif[39;49;00m [96mself[39;49;00m.source_address:
            extra_kw[[33m"[39;49;00m[33msource_address[39;49;00m[33m"[39;49;00m] = [96mself[39;49;00m.source_address
    
        [94mif[39;49;00m [96mself[39;49;00m.socket_options:
            extra_kw[[33m"[39;49;00m[33msocket_options[39;49;00m[33m"[39;49;00m] = [96mself[39;49;00m.socket_options
    
        [94mtry[39;49;00m:
            conn = connection.create_connection(
                ([96mself[39;49;00m._dns_host, [96mself[39;49;00m.port), [96mself[39;49;00m.timeout, **extra_kw
            )
    
        [94mexcept[39;49;00m SocketTimeout:
            [94mraise[39;49;00m ConnectTimeoutError(
                [96mself[39;49;00m,
                [33m"[39;49;00m[33mConnection to [39;49;00m[33m%s[39;49;00m[33m timed out. (connect timeout=[39;49;00m[33m%s[39;49;00m[33m)[39;49;00m[33m"[39;49;00m
                % ([96mself[39;49;00m.host, [96mself[39;49;00m.timeout),
            )
    
        [94mexcept[39;49;00m SocketError [94mas[39;49;00m e:
>           [94mraise[39;49;00m NewConnectionError(
                [96mself[39;49;00m, [33m"[39;49;00m[33mFailed to establish a new connection: [39;49;00m[33m%s[39;49;00m[33m"[39;49;00m % e
            )
[1m[31mE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x7fd1509f5690>: Failed to establish a new connection: [Errno 111] Connection refused[0m

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connection.py[0m:186: NewConnectionError

[33mDuring handling of the above exception, another exception occurred:[0m

self = <requests.adapters.HTTPAdapter object at 0x7fd152631fc0>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    [94mdef[39;49;00m [92msend[39;49;00m([96mself[39;49;00m, request, stream=[94mFalse[39;49;00m, timeout=[94mNone[39;49;00m, verify=[94mTrue[39;49;00m, cert=[94mNone[39;49;00m, proxies=[94mNone[39;49;00m):
    [90m    [39;49;00m[33m"""Sends PreparedRequest object. Returns Response object.[39;49;00m
    [33m[39;49;00m
    [33m    :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[39;49;00m
    [33m    :param stream: (optional) Whether to stream the request content.[39;49;00m
    [33m    :param timeout: (optional) How long to wait for the server to send[39;49;00m
    [33m        data before giving up, as a float, or a :ref:`(connect timeout,[39;49;00m
    [33m        read timeout) <timeouts>` tuple.[39;49;00m
    [33m    :type timeout: float or tuple or urllib3 Timeout object[39;49;00m
    [33m    :param verify: (optional) Either a boolean, in which case it controls whether[39;49;00m
    [33m        we verify the server's TLS certificate, or a string, in which case it[39;49;00m
    [33m        must be a path to a CA bundle to use[39;49;00m
    [33m    :param cert: (optional) Any user-provided SSL certificate to be trusted.[39;49;00m
    [33m    :param proxies: (optional) The proxies dictionary to apply to the request.[39;49;00m
    [33m    :rtype: requests.Response[39;49;00m
    [33m    """[39;49;00m
    
        [94mtry[39;49;00m:
            conn = [96mself[39;49;00m.get_connection(request.url, proxies)
        [94mexcept[39;49;00m LocationValueError [94mas[39;49;00m e:
            [94mraise[39;49;00m InvalidURL(e, request=request)
    
        [96mself[39;49;00m.cert_verify(conn, request.url, verify, cert)
        url = [96mself[39;49;00m.request_url(request, proxies)
        [96mself[39;49;00m.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = [95mnot[39;49;00m (request.body [95mis[39;49;00m [94mNone[39;49;00m [95mor[39;49;00m [33m'[39;49;00m[33mContent-Length[39;49;00m[33m'[39;49;00m [95min[39;49;00m request.headers)
    
        [94mif[39;49;00m [96misinstance[39;49;00m(timeout, [96mtuple[39;49;00m):
            [94mtry[39;49;00m:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            [94mexcept[39;49;00m [96mValueError[39;49;00m [94mas[39;49;00m e:
                [90m# this may raise a string formatting error.[39;49;00m
                err = ([33m"[39;49;00m[33mInvalid timeout [39;49;00m[33m{}[39;49;00m[33m. Pass a (connect, read) [39;49;00m[33m"[39;49;00m
                       [33m"[39;49;00m[33mtimeout tuple, or a single float to set [39;49;00m[33m"[39;49;00m
                       [33m"[39;49;00m[33mboth timeouts to the same value[39;49;00m[33m"[39;49;00m.format(timeout))
                [94mraise[39;49;00m [96mValueError[39;49;00m(err)
        [94melif[39;49;00m [96misinstance[39;49;00m(timeout, TimeoutSauce):
            [94mpass[39;49;00m
        [94melse[39;49;00m:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        [94mtry[39;49;00m:
            [94mif[39;49;00m [95mnot[39;49;00m chunked:
>               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=[94mFalse[39;49;00m,
                    assert_same_host=[94mFalse[39;49;00m,
                    preload_content=[94mFalse[39;49;00m,
                    decode_content=[94mFalse[39;49;00m,
                    retries=[96mself[39;49;00m.max_retries,
                    timeout=timeout
                )

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/adapters.py[0m:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fd1564632e0>
method = 'DELETE', url = '/api/v1/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/messages', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    [94mdef[39;49;00m [92murlopen[39;49;00m(
        [96mself[39;49;00m,
        method,
        url,
        body=[94mNone[39;49;00m,
        headers=[94mNone[39;49;00m,
        retries=[94mNone[39;49;00m,
        redirect=[94mTrue[39;49;00m,
        assert_same_host=[94mTrue[39;49;00m,
        timeout=_Default,
        pool_timeout=[94mNone[39;49;00m,
        release_conn=[94mNone[39;49;00m,
        chunked=[94mFalse[39;49;00m,
        body_pos=[94mNone[39;49;00m,
        **response_kw
    ):
    [90m    [39;49;00m[33m"""[39;49;00m
    [33m    Get a connection from the pool and perform an HTTP request. This is the[39;49;00m
    [33m    lowest level call for making a request, so you'll need to specify all[39;49;00m
    [33m    the raw details.[39;49;00m
    [33m[39;49;00m
    [33m    .. note::[39;49;00m
    [33m[39;49;00m
    [33m       More commonly, it's appropriate to use a convenience method provided[39;49;00m
    [33m       by :class:`.RequestMethods`, such as :meth:`request`.[39;49;00m
    [33m[39;49;00m
    [33m    .. note::[39;49;00m
    [33m[39;49;00m
    [33m       `release_conn` will only behave as expected if[39;49;00m
    [33m       `preload_content=False` because we want to make[39;49;00m
    [33m       `preload_content=False` the default behaviour someday soon without[39;49;00m
    [33m       breaking backwards compatibility.[39;49;00m
    [33m[39;49;00m
    [33m    :param method:[39;49;00m
    [33m        HTTP request method (such as GET, POST, PUT, etc.)[39;49;00m
    [33m[39;49;00m
    [33m    :param url:[39;49;00m
    [33m        The URL to perform the request on.[39;49;00m
    [33m[39;49;00m
    [33m    :param body:[39;49;00m
    [33m        Data to send in the request body, either :class:`str`, :class:`bytes`,[39;49;00m
    [33m        an iterable of :class:`str`/:class:`bytes`, or a file-like object.[39;49;00m
    [33m[39;49;00m
    [33m    :param headers:[39;49;00m
    [33m        Dictionary of custom headers to send, such as User-Agent,[39;49;00m
    [33m        If-None-Match, etc. If None, pool headers are used. If provided,[39;49;00m
    [33m        these headers completely replace any pool-specific headers.[39;49;00m
    [33m[39;49;00m
    [33m    :param retries:[39;49;00m
    [33m        Configure the number of retries to allow before raising a[39;49;00m
    [33m        :class:`~urllib3.exceptions.MaxRetryError` exception.[39;49;00m
    [33m[39;49;00m
    [33m        Pass ``None`` to retry until you receive a response. Pass a[39;49;00m
    [33m        :class:`~urllib3.util.retry.Retry` object for fine-grained control[39;49;00m
    [33m        over different types of retries.[39;49;00m
    [33m        Pass an integer number to retry connection errors that many times,[39;49;00m
    [33m        but no other types of errors. Pass zero to never retry.[39;49;00m
    [33m[39;49;00m
    [33m        If ``False``, then retries are disabled and any exception is raised[39;49;00m
    [33m        immediately. Also, instead of raising a MaxRetryError on redirects,[39;49;00m
    [33m        the redirect response will be returned.[39;49;00m
    [33m[39;49;00m
    [33m    :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.[39;49;00m
    [33m[39;49;00m
    [33m    :param redirect:[39;49;00m
    [33m        If True, automatically handle redirects (status codes 301, 302,[39;49;00m
    [33m        303, 307, 308). Each redirect counts as a retry. Disabling retries[39;49;00m
    [33m        will disable redirect, too.[39;49;00m
    [33m[39;49;00m
    [33m    :param assert_same_host:[39;49;00m
    [33m        If ``True``, will make sure that the host of the pool requests is[39;49;00m
    [33m        consistent else will raise HostChangedError. When ``False``, you can[39;49;00m
    [33m        use the pool on an HTTP proxy and request foreign hosts.[39;49;00m
    [33m[39;49;00m
    [33m    :param timeout:[39;49;00m
    [33m        If specified, overrides the default timeout for this one[39;49;00m
    [33m        request. It may be a float (in seconds) or an instance of[39;49;00m
    [33m        :class:`urllib3.util.Timeout`.[39;49;00m
    [33m[39;49;00m
    [33m    :param pool_timeout:[39;49;00m
    [33m        If set and the pool is set to block=True, then this method will[39;49;00m
    [33m        block for ``pool_timeout`` seconds and raise EmptyPoolError if no[39;49;00m
    [33m        connection is available within the time period.[39;49;00m
    [33m[39;49;00m
    [33m    :param release_conn:[39;49;00m
    [33m        If False, then the urlopen call will not release the connection[39;49;00m
    [33m        back into the pool once a response is received (but will release if[39;49;00m
    [33m        you read the entire contents of the response such as when[39;49;00m
    [33m        `preload_content=True`). This is useful if you're not preloading[39;49;00m
    [33m        the response's content immediately. You will need to call[39;49;00m
    [33m        ``r.release_conn()`` on the response ``r`` to return the connection[39;49;00m
    [33m        back into the pool. If None, it takes the value of[39;49;00m
    [33m        ``response_kw.get('preload_content', True)``.[39;49;00m
    [33m[39;49;00m
    [33m    :param chunked:[39;49;00m
    [33m        If True, urllib3 will send the body using chunked transfer[39;49;00m
    [33m        encoding. Otherwise, urllib3 will send the body using the standard[39;49;00m
    [33m        content-length form. Defaults to False.[39;49;00m
    [33m[39;49;00m
    [33m    :param int body_pos:[39;49;00m
    [33m        Position to seek to in file-like body in the event of a retry or[39;49;00m
    [33m        redirect. Typically this won't need to be set because urllib3 will[39;49;00m
    [33m        auto-populate the value when needed.[39;49;00m
    [33m[39;49;00m
    [33m    :param \\**response_kw:[39;49;00m
    [33m        Additional parameters are passed to[39;49;00m
    [33m        :meth:`urllib3.response.HTTPResponse.from_httplib`[39;49;00m
    [33m    """[39;49;00m
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        [94mif[39;49;00m headers [95mis[39;49;00m [94mNone[39;49;00m:
            headers = [96mself[39;49;00m.headers
    
        [94mif[39;49;00m [95mnot[39;49;00m [96misinstance[39;49;00m(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=[96mself[39;49;00m.retries)
    
        [94mif[39;49;00m release_conn [95mis[39;49;00m [94mNone[39;49;00m:
            release_conn = response_kw.get([33m"[39;49;00m[33mpreload_content[39;49;00m[33m"[39;49;00m, [94mTrue[39;49;00m)
    
        [90m# Check host[39;49;00m
        [94mif[39;49;00m assert_same_host [95mand[39;49;00m [95mnot[39;49;00m [96mself[39;49;00m.is_same_host(url):
            [94mraise[39;49;00m HostChangedError([96mself[39;49;00m, url, retries)
    
        [90m# Ensure that the URL we're connecting to is properly encoded[39;49;00m
        [94mif[39;49;00m url.startswith([33m"[39;49;00m[33m/[39;49;00m[33m"[39;49;00m):
            url = six.ensure_str(_encode_target(url))
        [94melse[39;49;00m:
            url = six.ensure_str(parsed_url.url)
    
        conn = [94mNone[39;49;00m
    
        [90m# Track whether `conn` needs to be released before[39;49;00m
        [90m# returning/raising/recursing. Update this variable if necessary, and[39;49;00m
        [90m# leave `release_conn` constant throughout the function. That way, if[39;49;00m
        [90m# the function recurses, the original value of `release_conn` will be[39;49;00m
        [90m# passed down into the recursive call, and its value will be respected.[39;49;00m
        [90m#[39;49;00m
        [90m# See issue #651 [1] for details.[39;49;00m
        [90m#[39;49;00m
        [90m# [1] <https://github.com/urllib3/urllib3/issues/651>[39;49;00m
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            [96mself[39;49;00m.proxy, [96mself[39;49;00m.proxy_config, destination_scheme
        )
    
        [90m# Merge the proxy headers. Only done when not using HTTP CONNECT. We[39;49;00m
        [90m# have to copy the headers dict so we can safely change it without those[39;49;00m
        [90m# changes being reflected in anyone else's copy.[39;49;00m
        [94mif[39;49;00m [95mnot[39;49;00m http_tunnel_required:
            headers = headers.copy()
            headers.update([96mself[39;49;00m.proxy_headers)
    
        [90m# Must keep the exception bound to a separate variable or else Python 3[39;49;00m
        [90m# complains about UnboundLocalError.[39;49;00m
        err = [94mNone[39;49;00m
    
        [90m# Keep track of whether we cleanly exited the except block. This[39;49;00m
        [90m# ensures we do proper cleanup in finally.[39;49;00m
        clean_exit = [94mFalse[39;49;00m
    
        [90m# Rewind body position, if needed. Record current position[39;49;00m
        [90m# for future rewinds in the event of a redirect/retry.[39;49;00m
        body_pos = set_file_position(body, body_pos)
    
        [94mtry[39;49;00m:
            [90m# Request a connection from the queue.[39;49;00m
            timeout_obj = [96mself[39;49;00m._get_timeout(timeout)
            conn = [96mself[39;49;00m._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = [96mself[39;49;00m.proxy [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m [95mand[39;49;00m [95mnot[39;49;00m [96mgetattr[39;49;00m(
                conn, [33m"[39;49;00m[33msock[39;49;00m[33m"[39;49;00m, [94mNone[39;49;00m
            )
            [94mif[39;49;00m is_new_proxy_conn [95mand[39;49;00m http_tunnel_required:
                [96mself[39;49;00m._prepare_proxy(conn)
    
            [90m# Make the request on the httplib connection object.[39;49;00m
            httplib_response = [96mself[39;49;00m._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            [90m# If we're going to release the connection in ``finally:``, then[39;49;00m
            [90m# the response doesn't need to know about the connection. Otherwise[39;49;00m
            [90m# it will also try to release it and we'll have a double-release[39;49;00m
            [90m# mess.[39;49;00m
            response_conn = conn [94mif[39;49;00m [95mnot[39;49;00m release_conn [94melse[39;49;00m [94mNone[39;49;00m
    
            [90m# Pass method to Response for length checking[39;49;00m
            response_kw[[33m"[39;49;00m[33mrequest_method[39;49;00m[33m"[39;49;00m] = method
    
            [90m# Import httplib's response into our own wrapper object[39;49;00m
            response = [96mself[39;49;00m.ResponseCls.from_httplib(
                httplib_response,
                pool=[96mself[39;49;00m,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            [90m# Everything went great![39;49;00m
            clean_exit = [94mTrue[39;49;00m
    
        [94mexcept[39;49;00m EmptyPoolError:
            [90m# Didn't get a connection from the pool, no need to clean up[39;49;00m
            clean_exit = [94mTrue[39;49;00m
            release_this_conn = [94mFalse[39;49;00m
            [94mraise[39;49;00m
    
        [94mexcept[39;49;00m (
            [96mTimeoutError[39;49;00m,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) [94mas[39;49;00m e:
            [90m# Discard the connection for these exceptions. It will be[39;49;00m
            [90m# replaced during the next _get_conn() call.[39;49;00m
            clean_exit = [94mFalse[39;49;00m
    
            [94mdef[39;49;00m [92m_is_ssl_error_message_from_http_proxy[39;49;00m(ssl_error):
                [90m# We're trying to detect the message 'WRONG_VERSION_NUMBER' but[39;49;00m
                [90m# SSLErrors are kinda all over the place when it comes to the message,[39;49;00m
                [90m# so we try to cover our bases here![39;49;00m
                message = [33m"[39;49;00m[33m [39;49;00m[33m"[39;49;00m.join(re.split([33m"[39;49;00m[33m[^a-z][39;49;00m[33m"[39;49;00m, [96mstr[39;49;00m(ssl_error).lower()))
                [94mreturn[39;49;00m (
                    [33m"[39;49;00m[33mwrong version number[39;49;00m[33m"[39;49;00m [95min[39;49;00m message [95mor[39;49;00m [33m"[39;49;00m[33munknown protocol[39;49;00m[33m"[39;49;00m [95min[39;49;00m message
                )
    
            [90m# Try to detect a common user error with proxies which is to[39;49;00m
            [90m# set an HTTP proxy to be HTTPS when it should be 'http://'[39;49;00m
            [90m# (ie {'http': 'http://proxy', 'https': 'https://proxy'})[39;49;00m
            [90m# Instead we add a nice error message and point to a URL.[39;49;00m
            [94mif[39;49;00m (
                [96misinstance[39;49;00m(e, BaseSSLError)
                [95mand[39;49;00m [96mself[39;49;00m.proxy
                [95mand[39;49;00m _is_ssl_error_message_from_http_proxy(e)
            ):
                e = ProxyError(
                    [33m"[39;49;00m[33mYour proxy appears to only use HTTP and not HTTPS, [39;49;00m[33m"[39;49;00m
                    [33m"[39;49;00m[33mtry changing your proxy URL to be HTTP. See: [39;49;00m[33m"[39;49;00m
                    [33m"[39;49;00m[33mhttps://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html[39;49;00m[33m"[39;49;00m
                    [33m"[39;49;00m[33m#https-proxy-error-http-proxy[39;49;00m[33m"[39;49;00m,
                    SSLError(e),
                )
            [94melif[39;49;00m [96misinstance[39;49;00m(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            [94melif[39;49;00m [96misinstance[39;49;00m(e, (SocketError, NewConnectionError)) [95mand[39;49;00m [96mself[39;49;00m.proxy:
                e = ProxyError([33m"[39;49;00m[33mCannot connect to proxy.[39;49;00m[33m"[39;49;00m, e)
            [94melif[39;49;00m [96misinstance[39;49;00m(e, (SocketError, HTTPException)):
                e = ProtocolError([33m"[39;49;00m[33mConnection aborted.[39;49;00m[33m"[39;49;00m, e)
    
>           retries = retries.increment(
                method, url, error=e, _pool=[96mself[39;49;00m, _stacktrace=sys.exc_info()[[94m2[39;49;00m]
            )

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connectionpool.py[0m:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'DELETE', url = '/api/v1/messages', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fd1509f5690>: Failed to establish a new connection: [Errno 111] Connection refused')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fd1564632e0>
_stacktrace = <traceback object at 0x7fd150a18b00>

    [94mdef[39;49;00m [92mincrement[39;49;00m(
        [96mself[39;49;00m,
        method=[94mNone[39;49;00m,
        url=[94mNone[39;49;00m,
        response=[94mNone[39;49;00m,
        error=[94mNone[39;49;00m,
        _pool=[94mNone[39;49;00m,
        _stacktrace=[94mNone[39;49;00m,
    ):
    [90m    [39;49;00m[33m"""Return a new Retry object with incremented retry counters.[39;49;00m
    [33m[39;49;00m
    [33m    :param response: A response object, or None, if the server did not[39;49;00m
    [33m        return a response.[39;49;00m
    [33m    :type response: :class:`~urllib3.response.HTTPResponse`[39;49;00m
    [33m    :param Exception error: An error encountered during the request, or[39;49;00m
    [33m        None if the response was received successfully.[39;49;00m
    [33m[39;49;00m
    [33m    :return: A new ``Retry`` object.[39;49;00m
    [33m    """[39;49;00m
        [94mif[39;49;00m [96mself[39;49;00m.total [95mis[39;49;00m [94mFalse[39;49;00m [95mand[39;49;00m error:
            [90m# Disabled, indicate to re-raise the error.[39;49;00m
            [94mraise[39;49;00m six.reraise([96mtype[39;49;00m(error), error, _stacktrace)
    
        total = [96mself[39;49;00m.total
        [94mif[39;49;00m total [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
            total -= [94m1[39;49;00m
    
        connect = [96mself[39;49;00m.connect
        read = [96mself[39;49;00m.read
        redirect = [96mself[39;49;00m.redirect
        status_count = [96mself[39;49;00m.status
        other = [96mself[39;49;00m.other
        cause = [33m"[39;49;00m[33munknown[39;49;00m[33m"[39;49;00m
        status = [94mNone[39;49;00m
        redirect_location = [94mNone[39;49;00m
    
        [94mif[39;49;00m error [95mand[39;49;00m [96mself[39;49;00m._is_connection_error(error):
            [90m# Connect retry?[39;49;00m
            [94mif[39;49;00m connect [95mis[39;49;00m [94mFalse[39;49;00m:
                [94mraise[39;49;00m six.reraise([96mtype[39;49;00m(error), error, _stacktrace)
            [94melif[39;49;00m connect [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                connect -= [94m1[39;49;00m
    
        [94melif[39;49;00m error [95mand[39;49;00m [96mself[39;49;00m._is_read_error(error):
            [90m# Read retry?[39;49;00m
            [94mif[39;49;00m read [95mis[39;49;00m [94mFalse[39;49;00m [95mor[39;49;00m [95mnot[39;49;00m [96mself[39;49;00m._is_method_retryable(method):
                [94mraise[39;49;00m six.reraise([96mtype[39;49;00m(error), error, _stacktrace)
            [94melif[39;49;00m read [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                read -= [94m1[39;49;00m
    
        [94melif[39;49;00m error:
            [90m# Other retry?[39;49;00m
            [94mif[39;49;00m other [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                other -= [94m1[39;49;00m
    
        [94melif[39;49;00m response [95mand[39;49;00m response.get_redirect_location():
            [90m# Redirect retry?[39;49;00m
            [94mif[39;49;00m redirect [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                redirect -= [94m1[39;49;00m
            cause = [33m"[39;49;00m[33mtoo many redirects[39;49;00m[33m"[39;49;00m
            redirect_location = response.get_redirect_location()
            status = response.status
    
        [94melse[39;49;00m:
            [90m# Incrementing because of a server error like a 500 in[39;49;00m
            [90m# status_forcelist and the given method is in the allowed_methods[39;49;00m
            cause = ResponseError.GENERIC_ERROR
            [94mif[39;49;00m response [95mand[39;49;00m response.status:
                [94mif[39;49;00m status_count [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                    status_count -= [94m1[39;49;00m
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = [96mself[39;49;00m.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = [96mself[39;49;00m.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        [94mif[39;49;00m new_retry.is_exhausted():
>           [94mraise[39;49;00m MaxRetryError(_pool, url, error [95mor[39;49;00m ResponseError(cause))
[1m[31mE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=8025): Max retries exceeded with url: /api/v1/messages (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fd1509f5690>: Failed to establish a new connection: [Errno 111] Connection refused'))[0m

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/util/retry.py[0m:592: MaxRetryError

[33mDuring handling of the above exception, another exception occurred:[0m

client = <starlette.testclient.TestClient object at 0x7fd152686ef0>

    [94mdef[39;49;00m [92mtest_signup[39;49;00m(client: TestClient) -> [94mNone[39;49;00m:
>       mailhog_history_clear = requests.delete([33mf[39;49;00m[33m"[39;49;00m[33m{[39;49;00mMAILHOG_URL[33m}[39;49;00m[33m/v1/messages[39;49;00m[33m"[39;49;00m)

[1m[31mtests/api/api_v1/test_auth.py[0m:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/api.py[0m:159: in delete
    [94mreturn[39;49;00m request([33m'[39;49;00m[33mdelete[39;49;00m[33m'[39;49;00m, url, **kwargs)
[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/api.py[0m:61: in request
    [94mreturn[39;49;00m session.request(method=method, url=url, **kwargs)
[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/sessions.py[0m:529: in request
    resp = [96mself[39;49;00m.send(prep, **send_kwargs)
[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/sessions.py[0m:645: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7fd152631fc0>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    [94mdef[39;49;00m [92msend[39;49;00m([96mself[39;49;00m, request, stream=[94mFalse[39;49;00m, timeout=[94mNone[39;49;00m, verify=[94mTrue[39;49;00m, cert=[94mNone[39;49;00m, proxies=[94mNone[39;49;00m):
    [90m    [39;49;00m[33m"""Sends PreparedRequest object. Returns Response object.[39;49;00m
    [33m[39;49;00m
    [33m    :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[39;49;00m
    [33m    :param stream: (optional) Whether to stream the request content.[39;49;00m
    [33m    :param timeout: (optional) How long to wait for the server to send[39;49;00m
    [33m        data before giving up, as a float, or a :ref:`(connect timeout,[39;49;00m
    [33m        read timeout) <timeouts>` tuple.[39;49;00m
    [33m    :type timeout: float or tuple or urllib3 Timeout object[39;49;00m
    [33m    :param verify: (optional) Either a boolean, in which case it controls whether[39;49;00m
    [33m        we verify the server's TLS certificate, or a string, in which case it[39;49;00m
    [33m        must be a path to a CA bundle to use[39;49;00m
    [33m    :param cert: (optional) Any user-provided SSL certificate to be trusted.[39;49;00m
    [33m    :param proxies: (optional) The proxies dictionary to apply to the request.[39;49;00m
    [33m    :rtype: requests.Response[39;49;00m
    [33m    """[39;49;00m
    
        [94mtry[39;49;00m:
            conn = [96mself[39;49;00m.get_connection(request.url, proxies)
        [94mexcept[39;49;00m LocationValueError [94mas[39;49;00m e:
            [94mraise[39;49;00m InvalidURL(e, request=request)
    
        [96mself[39;49;00m.cert_verify(conn, request.url, verify, cert)
        url = [96mself[39;49;00m.request_url(request, proxies)
        [96mself[39;49;00m.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = [95mnot[39;49;00m (request.body [95mis[39;49;00m [94mNone[39;49;00m [95mor[39;49;00m [33m'[39;49;00m[33mContent-Length[39;49;00m[33m'[39;49;00m [95min[39;49;00m request.headers)
    
        [94mif[39;49;00m [96misinstance[39;49;00m(timeout, [96mtuple[39;49;00m):
            [94mtry[39;49;00m:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            [94mexcept[39;49;00m [96mValueError[39;49;00m [94mas[39;49;00m e:
                [90m# this may raise a string formatting error.[39;49;00m
                err = ([33m"[39;49;00m[33mInvalid timeout [39;49;00m[33m{}[39;49;00m[33m. Pass a (connect, read) [39;49;00m[33m"[39;49;00m
                       [33m"[39;49;00m[33mtimeout tuple, or a single float to set [39;49;00m[33m"[39;49;00m
                       [33m"[39;49;00m[33mboth timeouts to the same value[39;49;00m[33m"[39;49;00m.format(timeout))
                [94mraise[39;49;00m [96mValueError[39;49;00m(err)
        [94melif[39;49;00m [96misinstance[39;49;00m(timeout, TimeoutSauce):
            [94mpass[39;49;00m
        [94melse[39;49;00m:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        [94mtry[39;49;00m:
            [94mif[39;49;00m [95mnot[39;49;00m chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=[94mFalse[39;49;00m,
                    assert_same_host=[94mFalse[39;49;00m,
                    preload_content=[94mFalse[39;49;00m,
                    decode_content=[94mFalse[39;49;00m,
                    retries=[96mself[39;49;00m.max_retries,
                    timeout=timeout
                )
    
            [90m# Send the request.[39;49;00m
            [94melse[39;49;00m:
                [94mif[39;49;00m [96mhasattr[39;49;00m(conn, [33m'[39;49;00m[33mproxy_pool[39;49;00m[33m'[39;49;00m):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                [94mtry[39;49;00m:
                    skip_host = [33m'[39;49;00m[33mHost[39;49;00m[33m'[39;49;00m [95min[39;49;00m request.headers
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=[94mTrue[39;49;00m,
                                        skip_host=skip_host)
    
                    [94mfor[39;49;00m header, value [95min[39;49;00m request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    [94mfor[39;49;00m i [95min[39;49;00m request.body:
                        low_conn.send([96mhex[39;49;00m([96mlen[39;49;00m(i))[[94m2[39;49;00m:].encode([33m'[39;49;00m[33mutf-8[39;49;00m[33m'[39;49;00m))
                        low_conn.send([33mb[39;49;00m[33m'[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m'[39;49;00m)
                        low_conn.send(i)
                        low_conn.send([33mb[39;49;00m[33m'[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m'[39;49;00m)
                    low_conn.send([33mb[39;49;00m[33m'[39;49;00m[33m0[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m'[39;49;00m)
    
                    [90m# Receive the response from the server[39;49;00m
                    [94mtry[39;49;00m:
                        [90m# For Python 2.7, use buffering of HTTP responses[39;49;00m
                        r = low_conn.getresponse(buffering=[94mTrue[39;49;00m)
                    [94mexcept[39;49;00m [96mTypeError[39;49;00m:
                        [90m# For compatibility with Python 3.3+[39;49;00m
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=[94mFalse[39;49;00m,
                        decode_content=[94mFalse[39;49;00m
                    )
                [94mexcept[39;49;00m:
                    [90m# If we hit any problems here, clean up the connection.[39;49;00m
                    [90m# Then, reraise so that we can handle the actual exception.[39;49;00m
                    low_conn.close()
                    [94mraise[39;49;00m
    
        [94mexcept[39;49;00m (ProtocolError, socket.error) [94mas[39;49;00m err:
            [94mraise[39;49;00m [96mConnectionError[39;49;00m(err, request=request)
    
        [94mexcept[39;49;00m MaxRetryError [94mas[39;49;00m e:
            [94mif[39;49;00m [96misinstance[39;49;00m(e.reason, ConnectTimeoutError):
                [90m# TODO: Remove this in 3.0.0: see #2811[39;49;00m
                [94mif[39;49;00m [95mnot[39;49;00m [96misinstance[39;49;00m(e.reason, NewConnectionError):
                    [94mraise[39;49;00m ConnectTimeout(e, request=request)
    
            [94mif[39;49;00m [96misinstance[39;49;00m(e.reason, ResponseError):
                [94mraise[39;49;00m RetryError(e, request=request)
    
            [94mif[39;49;00m [96misinstance[39;49;00m(e.reason, _ProxyError):
                [94mraise[39;49;00m ProxyError(e, request=request)
    
            [94mif[39;49;00m [96misinstance[39;49;00m(e.reason, _SSLError):
                [90m# This branch is for urllib3 v1.22 and later.[39;49;00m
                [94mraise[39;49;00m SSLError(e, request=request)
    
>           [94mraise[39;49;00m [96mConnectionError[39;49;00m(e, request=request)
[1m[31mE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=8025): Max retries exceeded with url: /api/v1/messages (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fd1509f5690>: Failed to establish a new connection: [Errno 111] Connection refused'))[0m

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/adapters.py[0m:519: ConnectionError
[31m[1m___________________________ test_verification_email ____________________________[0m

self = <urllib3.connection.HTTPConnection object at 0x7fd15080d570>

    [94mdef[39;49;00m [92m_new_conn[39;49;00m([96mself[39;49;00m):
    [90m    [39;49;00m[33m"""Establish a socket connection and set nodelay settings on it.[39;49;00m
    [33m[39;49;00m
    [33m    :return: New socket connection.[39;49;00m
    [33m    """[39;49;00m
        extra_kw = {}
        [94mif[39;49;00m [96mself[39;49;00m.source_address:
            extra_kw[[33m"[39;49;00m[33msource_address[39;49;00m[33m"[39;49;00m] = [96mself[39;49;00m.source_address
    
        [94mif[39;49;00m [96mself[39;49;00m.socket_options:
            extra_kw[[33m"[39;49;00m[33msocket_options[39;49;00m[33m"[39;49;00m] = [96mself[39;49;00m.socket_options
    
        [94mtry[39;49;00m:
>           conn = connection.create_connection(
                ([96mself[39;49;00m._dns_host, [96mself[39;49;00m.port), [96mself[39;49;00m.timeout, **extra_kw
            )

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connection.py[0m:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 8025), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    [94mdef[39;49;00m [92mcreate_connection[39;49;00m(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=[94mNone[39;49;00m,
        socket_options=[94mNone[39;49;00m,
    ):
    [90m    [39;49;00m[33m"""Connect to *address* and return the socket object.[39;49;00m
    [33m[39;49;00m
    [33m    Convenience function.  Connect to *address* (a 2-tuple ``(host,[39;49;00m
    [33m    port)``) and return the socket object.  Passing the optional[39;49;00m
    [33m    *timeout* parameter will set the timeout on the socket instance[39;49;00m
    [33m    before attempting to connect.  If no *timeout* is supplied, the[39;49;00m
    [33m    global default timeout setting returned by :func:`socket.getdefaulttimeout`[39;49;00m
    [33m    is used.  If *source_address* is set it must be a tuple of (host, port)[39;49;00m
    [33m    for the socket to bind as a source address before making the connection.[39;49;00m
    [33m    An host of '' or port 0 tells the OS to use the default.[39;49;00m
    [33m    """[39;49;00m
    
        host, port = address
        [94mif[39;49;00m host.startswith([33m"[39;49;00m[33m[[39;49;00m[33m"[39;49;00m):
            host = host.strip([33m"[39;49;00m[33m[][39;49;00m[33m"[39;49;00m)
        err = [94mNone[39;49;00m
    
        [90m# Using the value from allowed_gai_family() in the context of getaddrinfo lets[39;49;00m
        [90m# us select whether to work with IPv4 DNS records, IPv6 records, or both.[39;49;00m
        [90m# The original create_connection function always returns all records.[39;49;00m
        family = allowed_gai_family()
    
        [94mtry[39;49;00m:
            host.encode([33m"[39;49;00m[33midna[39;49;00m[33m"[39;49;00m)
        [94mexcept[39;49;00m [96mUnicodeError[39;49;00m:
            [94mreturn[39;49;00m six.raise_from(
                LocationParseError([33mu[39;49;00m[33m"[39;49;00m[33m'[39;49;00m[33m%s[39;49;00m[33m'[39;49;00m[33m, label empty or too long[39;49;00m[33m"[39;49;00m % host), [94mNone[39;49;00m
            )
    
        [94mfor[39;49;00m res [95min[39;49;00m socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = [94mNone[39;49;00m
            [94mtry[39;49;00m:
                sock = socket.socket(af, socktype, proto)
    
                [90m# If provided, set socket level options before connecting.[39;49;00m
                _set_socket_options(sock, socket_options)
    
                [94mif[39;49;00m timeout [95mis[39;49;00m [95mnot[39;49;00m socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                [94mif[39;49;00m source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                [94mreturn[39;49;00m sock
    
            [94mexcept[39;49;00m socket.error [94mas[39;49;00m e:
                err = e
                [94mif[39;49;00m sock [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                    sock.close()
                    sock = [94mNone[39;49;00m
    
        [94mif[39;49;00m err [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
>           [94mraise[39;49;00m err

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/util/connection.py[0m:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 8025), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    [94mdef[39;49;00m [92mcreate_connection[39;49;00m(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=[94mNone[39;49;00m,
        socket_options=[94mNone[39;49;00m,
    ):
    [90m    [39;49;00m[33m"""Connect to *address* and return the socket object.[39;49;00m
    [33m[39;49;00m
    [33m    Convenience function.  Connect to *address* (a 2-tuple ``(host,[39;49;00m
    [33m    port)``) and return the socket object.  Passing the optional[39;49;00m
    [33m    *timeout* parameter will set the timeout on the socket instance[39;49;00m
    [33m    before attempting to connect.  If no *timeout* is supplied, the[39;49;00m
    [33m    global default timeout setting returned by :func:`socket.getdefaulttimeout`[39;49;00m
    [33m    is used.  If *source_address* is set it must be a tuple of (host, port)[39;49;00m
    [33m    for the socket to bind as a source address before making the connection.[39;49;00m
    [33m    An host of '' or port 0 tells the OS to use the default.[39;49;00m
    [33m    """[39;49;00m
    
        host, port = address
        [94mif[39;49;00m host.startswith([33m"[39;49;00m[33m[[39;49;00m[33m"[39;49;00m):
            host = host.strip([33m"[39;49;00m[33m[][39;49;00m[33m"[39;49;00m)
        err = [94mNone[39;49;00m
    
        [90m# Using the value from allowed_gai_family() in the context of getaddrinfo lets[39;49;00m
        [90m# us select whether to work with IPv4 DNS records, IPv6 records, or both.[39;49;00m
        [90m# The original create_connection function always returns all records.[39;49;00m
        family = allowed_gai_family()
    
        [94mtry[39;49;00m:
            host.encode([33m"[39;49;00m[33midna[39;49;00m[33m"[39;49;00m)
        [94mexcept[39;49;00m [96mUnicodeError[39;49;00m:
            [94mreturn[39;49;00m six.raise_from(
                LocationParseError([33mu[39;49;00m[33m"[39;49;00m[33m'[39;49;00m[33m%s[39;49;00m[33m'[39;49;00m[33m, label empty or too long[39;49;00m[33m"[39;49;00m % host), [94mNone[39;49;00m
            )
    
        [94mfor[39;49;00m res [95min[39;49;00m socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = [94mNone[39;49;00m
            [94mtry[39;49;00m:
                sock = socket.socket(af, socktype, proto)
    
                [90m# If provided, set socket level options before connecting.[39;49;00m
                _set_socket_options(sock, socket_options)
    
                [94mif[39;49;00m timeout [95mis[39;49;00m [95mnot[39;49;00m socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                [94mif[39;49;00m source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
[1m[31mE               ConnectionRefusedError: [Errno 111] Connection refused[0m

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/util/connection.py[0m:85: ConnectionRefusedError

[33mDuring handling of the above exception, another exception occurred:[0m

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fd15080dae0>
method = 'GET', url = '/api/v2/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v2/messages', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    [94mdef[39;49;00m [92murlopen[39;49;00m(
        [96mself[39;49;00m,
        method,
        url,
        body=[94mNone[39;49;00m,
        headers=[94mNone[39;49;00m,
        retries=[94mNone[39;49;00m,
        redirect=[94mTrue[39;49;00m,
        assert_same_host=[94mTrue[39;49;00m,
        timeout=_Default,
        pool_timeout=[94mNone[39;49;00m,
        release_conn=[94mNone[39;49;00m,
        chunked=[94mFalse[39;49;00m,
        body_pos=[94mNone[39;49;00m,
        **response_kw
    ):
    [90m    [39;49;00m[33m"""[39;49;00m
    [33m    Get a connection from the pool and perform an HTTP request. This is the[39;49;00m
    [33m    lowest level call for making a request, so you'll need to specify all[39;49;00m
    [33m    the raw details.[39;49;00m
    [33m[39;49;00m
    [33m    .. note::[39;49;00m
    [33m[39;49;00m
    [33m       More commonly, it's appropriate to use a convenience method provided[39;49;00m
    [33m       by :class:`.RequestMethods`, such as :meth:`request`.[39;49;00m
    [33m[39;49;00m
    [33m    .. note::[39;49;00m
    [33m[39;49;00m
    [33m       `release_conn` will only behave as expected if[39;49;00m
    [33m       `preload_content=False` because we want to make[39;49;00m
    [33m       `preload_content=False` the default behaviour someday soon without[39;49;00m
    [33m       breaking backwards compatibility.[39;49;00m
    [33m[39;49;00m
    [33m    :param method:[39;49;00m
    [33m        HTTP request method (such as GET, POST, PUT, etc.)[39;49;00m
    [33m[39;49;00m
    [33m    :param url:[39;49;00m
    [33m        The URL to perform the request on.[39;49;00m
    [33m[39;49;00m
    [33m    :param body:[39;49;00m
    [33m        Data to send in the request body, either :class:`str`, :class:`bytes`,[39;49;00m
    [33m        an iterable of :class:`str`/:class:`bytes`, or a file-like object.[39;49;00m
    [33m[39;49;00m
    [33m    :param headers:[39;49;00m
    [33m        Dictionary of custom headers to send, such as User-Agent,[39;49;00m
    [33m        If-None-Match, etc. If None, pool headers are used. If provided,[39;49;00m
    [33m        these headers completely replace any pool-specific headers.[39;49;00m
    [33m[39;49;00m
    [33m    :param retries:[39;49;00m
    [33m        Configure the number of retries to allow before raising a[39;49;00m
    [33m        :class:`~urllib3.exceptions.MaxRetryError` exception.[39;49;00m
    [33m[39;49;00m
    [33m        Pass ``None`` to retry until you receive a response. Pass a[39;49;00m
    [33m        :class:`~urllib3.util.retry.Retry` object for fine-grained control[39;49;00m
    [33m        over different types of retries.[39;49;00m
    [33m        Pass an integer number to retry connection errors that many times,[39;49;00m
    [33m        but no other types of errors. Pass zero to never retry.[39;49;00m
    [33m[39;49;00m
    [33m        If ``False``, then retries are disabled and any exception is raised[39;49;00m
    [33m        immediately. Also, instead of raising a MaxRetryError on redirects,[39;49;00m
    [33m        the redirect response will be returned.[39;49;00m
    [33m[39;49;00m
    [33m    :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.[39;49;00m
    [33m[39;49;00m
    [33m    :param redirect:[39;49;00m
    [33m        If True, automatically handle redirects (status codes 301, 302,[39;49;00m
    [33m        303, 307, 308). Each redirect counts as a retry. Disabling retries[39;49;00m
    [33m        will disable redirect, too.[39;49;00m
    [33m[39;49;00m
    [33m    :param assert_same_host:[39;49;00m
    [33m        If ``True``, will make sure that the host of the pool requests is[39;49;00m
    [33m        consistent else will raise HostChangedError. When ``False``, you can[39;49;00m
    [33m        use the pool on an HTTP proxy and request foreign hosts.[39;49;00m
    [33m[39;49;00m
    [33m    :param timeout:[39;49;00m
    [33m        If specified, overrides the default timeout for this one[39;49;00m
    [33m        request. It may be a float (in seconds) or an instance of[39;49;00m
    [33m        :class:`urllib3.util.Timeout`.[39;49;00m
    [33m[39;49;00m
    [33m    :param pool_timeout:[39;49;00m
    [33m        If set and the pool is set to block=True, then this method will[39;49;00m
    [33m        block for ``pool_timeout`` seconds and raise EmptyPoolError if no[39;49;00m
    [33m        connection is available within the time period.[39;49;00m
    [33m[39;49;00m
    [33m    :param release_conn:[39;49;00m
    [33m        If False, then the urlopen call will not release the connection[39;49;00m
    [33m        back into the pool once a response is received (but will release if[39;49;00m
    [33m        you read the entire contents of the response such as when[39;49;00m
    [33m        `preload_content=True`). This is useful if you're not preloading[39;49;00m
    [33m        the response's content immediately. You will need to call[39;49;00m
    [33m        ``r.release_conn()`` on the response ``r`` to return the connection[39;49;00m
    [33m        back into the pool. If None, it takes the value of[39;49;00m
    [33m        ``response_kw.get('preload_content', True)``.[39;49;00m
    [33m[39;49;00m
    [33m    :param chunked:[39;49;00m
    [33m        If True, urllib3 will send the body using chunked transfer[39;49;00m
    [33m        encoding. Otherwise, urllib3 will send the body using the standard[39;49;00m
    [33m        content-length form. Defaults to False.[39;49;00m
    [33m[39;49;00m
    [33m    :param int body_pos:[39;49;00m
    [33m        Position to seek to in file-like body in the event of a retry or[39;49;00m
    [33m        redirect. Typically this won't need to be set because urllib3 will[39;49;00m
    [33m        auto-populate the value when needed.[39;49;00m
    [33m[39;49;00m
    [33m    :param \\**response_kw:[39;49;00m
    [33m        Additional parameters are passed to[39;49;00m
    [33m        :meth:`urllib3.response.HTTPResponse.from_httplib`[39;49;00m
    [33m    """[39;49;00m
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        [94mif[39;49;00m headers [95mis[39;49;00m [94mNone[39;49;00m:
            headers = [96mself[39;49;00m.headers
    
        [94mif[39;49;00m [95mnot[39;49;00m [96misinstance[39;49;00m(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=[96mself[39;49;00m.retries)
    
        [94mif[39;49;00m release_conn [95mis[39;49;00m [94mNone[39;49;00m:
            release_conn = response_kw.get([33m"[39;49;00m[33mpreload_content[39;49;00m[33m"[39;49;00m, [94mTrue[39;49;00m)
    
        [90m# Check host[39;49;00m
        [94mif[39;49;00m assert_same_host [95mand[39;49;00m [95mnot[39;49;00m [96mself[39;49;00m.is_same_host(url):
            [94mraise[39;49;00m HostChangedError([96mself[39;49;00m, url, retries)
    
        [90m# Ensure that the URL we're connecting to is properly encoded[39;49;00m
        [94mif[39;49;00m url.startswith([33m"[39;49;00m[33m/[39;49;00m[33m"[39;49;00m):
            url = six.ensure_str(_encode_target(url))
        [94melse[39;49;00m:
            url = six.ensure_str(parsed_url.url)
    
        conn = [94mNone[39;49;00m
    
        [90m# Track whether `conn` needs to be released before[39;49;00m
        [90m# returning/raising/recursing. Update this variable if necessary, and[39;49;00m
        [90m# leave `release_conn` constant throughout the function. That way, if[39;49;00m
        [90m# the function recurses, the original value of `release_conn` will be[39;49;00m
        [90m# passed down into the recursive call, and its value will be respected.[39;49;00m
        [90m#[39;49;00m
        [90m# See issue #651 [1] for details.[39;49;00m
        [90m#[39;49;00m
        [90m# [1] <https://github.com/urllib3/urllib3/issues/651>[39;49;00m
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            [96mself[39;49;00m.proxy, [96mself[39;49;00m.proxy_config, destination_scheme
        )
    
        [90m# Merge the proxy headers. Only done when not using HTTP CONNECT. We[39;49;00m
        [90m# have to copy the headers dict so we can safely change it without those[39;49;00m
        [90m# changes being reflected in anyone else's copy.[39;49;00m
        [94mif[39;49;00m [95mnot[39;49;00m http_tunnel_required:
            headers = headers.copy()
            headers.update([96mself[39;49;00m.proxy_headers)
    
        [90m# Must keep the exception bound to a separate variable or else Python 3[39;49;00m
        [90m# complains about UnboundLocalError.[39;49;00m
        err = [94mNone[39;49;00m
    
        [90m# Keep track of whether we cleanly exited the except block. This[39;49;00m
        [90m# ensures we do proper cleanup in finally.[39;49;00m
        clean_exit = [94mFalse[39;49;00m
    
        [90m# Rewind body position, if needed. Record current position[39;49;00m
        [90m# for future rewinds in the event of a redirect/retry.[39;49;00m
        body_pos = set_file_position(body, body_pos)
    
        [94mtry[39;49;00m:
            [90m# Request a connection from the queue.[39;49;00m
            timeout_obj = [96mself[39;49;00m._get_timeout(timeout)
            conn = [96mself[39;49;00m._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = [96mself[39;49;00m.proxy [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m [95mand[39;49;00m [95mnot[39;49;00m [96mgetattr[39;49;00m(
                conn, [33m"[39;49;00m[33msock[39;49;00m[33m"[39;49;00m, [94mNone[39;49;00m
            )
            [94mif[39;49;00m is_new_proxy_conn [95mand[39;49;00m http_tunnel_required:
                [96mself[39;49;00m._prepare_proxy(conn)
    
            [90m# Make the request on the httplib connection object.[39;49;00m
>           httplib_response = [96mself[39;49;00m._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connectionpool.py[0m:703: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fd15080dae0>
conn = <urllib3.connection.HTTPConnection object at 0x7fd15080d570>
method = 'GET', url = '/api/v2/messages'
timeout = Timeout(connect=None, read=None, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'}}
timeout_obj = Timeout(connect=None, read=None, total=None)

    [94mdef[39;49;00m [92m_make_request[39;49;00m(
        [96mself[39;49;00m, conn, method, url, timeout=_Default, chunked=[94mFalse[39;49;00m, **httplib_request_kw
    ):
    [90m    [39;49;00m[33m"""[39;49;00m
    [33m    Perform a request on a given urllib connection object taken from our[39;49;00m
    [33m    pool.[39;49;00m
    [33m[39;49;00m
    [33m    :param conn:[39;49;00m
    [33m        a connection from one of our connection pools[39;49;00m
    [33m[39;49;00m
    [33m    :param timeout:[39;49;00m
    [33m        Socket timeout in seconds for the request. This can be a[39;49;00m
    [33m        float or integer, which will set the same timeout value for[39;49;00m
    [33m        the socket connect and the socket read, or an instance of[39;49;00m
    [33m        :class:`urllib3.util.Timeout`, which gives you more fine-grained[39;49;00m
    [33m        control over your timeouts.[39;49;00m
    [33m    """[39;49;00m
        [96mself[39;49;00m.num_requests += [94m1[39;49;00m
    
        timeout_obj = [96mself[39;49;00m._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        [90m# Trigger any extra validation we need to do.[39;49;00m
        [94mtry[39;49;00m:
            [96mself[39;49;00m._validate_conn(conn)
        [94mexcept[39;49;00m (SocketTimeout, BaseSSLError) [94mas[39;49;00m e:
            [90m# Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.[39;49;00m
            [96mself[39;49;00m._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            [94mraise[39;49;00m
    
        [90m# conn.request() calls http.client.*.request, not the method in[39;49;00m
        [90m# urllib3.request. It also calls makefile (recv) on the socket.[39;49;00m
        [94mtry[39;49;00m:
            [94mif[39;49;00m chunked:
                conn.request_chunked(method, url, **httplib_request_kw)
            [94melse[39;49;00m:
>               conn.request(method, url, **httplib_request_kw)

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connectionpool.py[0m:398: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd15080d570>
method = 'GET', url = '/api/v2/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'}

    [94mdef[39;49;00m [92mrequest[39;49;00m([96mself[39;49;00m, method, url, body=[94mNone[39;49;00m, headers=[94mNone[39;49;00m):
        [94mif[39;49;00m headers [95mis[39;49;00m [94mNone[39;49;00m:
            headers = {}
        [94melse[39;49;00m:
            [90m# Avoid modifying the headers passed into .request()[39;49;00m
            headers = headers.copy()
        [94mif[39;49;00m [33m"[39;49;00m[33muser-agent[39;49;00m[33m"[39;49;00m [95mnot[39;49;00m [95min[39;49;00m (six.ensure_str(k.lower()) [94mfor[39;49;00m k [95min[39;49;00m headers):
            headers[[33m"[39;49;00m[33mUser-Agent[39;49;00m[33m"[39;49;00m] = _get_default_user_agent()
>       [96msuper[39;49;00m(HTTPConnection, [96mself[39;49;00m).request(method, url, body=body, headers=headers)

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connection.py[0m:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd15080d570>
method = 'GET', url = '/api/v2/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'}

    [94mdef[39;49;00m [92mrequest[39;49;00m([96mself[39;49;00m, method, url, body=[94mNone[39;49;00m, headers={}, *,
                encode_chunked=[94mFalse[39;49;00m):
    [90m    [39;49;00m[33m"""Send a complete request to the server."""[39;49;00m
>       [96mself[39;49;00m._send_request(method, url, body, headers, encode_chunked)

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:1282: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd15080d570>
method = 'GET', url = '/api/v2/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'}
encode_chunked = False

    [94mdef[39;49;00m [92m_send_request[39;49;00m([96mself[39;49;00m, method, url, body, headers, encode_chunked):
        [90m# Honor explicitly requested Host: and Accept-Encoding: headers.[39;49;00m
        header_names = [96mfrozenset[39;49;00m(k.lower() [94mfor[39;49;00m k [95min[39;49;00m headers)
        skips = {}
        [94mif[39;49;00m [33m'[39;49;00m[33mhost[39;49;00m[33m'[39;49;00m [95min[39;49;00m header_names:
            skips[[33m'[39;49;00m[33mskip_host[39;49;00m[33m'[39;49;00m] = [94m1[39;49;00m
        [94mif[39;49;00m [33m'[39;49;00m[33maccept-encoding[39;49;00m[33m'[39;49;00m [95min[39;49;00m header_names:
            skips[[33m'[39;49;00m[33mskip_accept_encoding[39;49;00m[33m'[39;49;00m] = [94m1[39;49;00m
    
        [96mself[39;49;00m.putrequest(method, url, **skips)
    
        [90m# chunked encoding will happen if HTTP/1.1 is used and either[39;49;00m
        [90m# the caller passes encode_chunked=True or the following[39;49;00m
        [90m# conditions hold:[39;49;00m
        [90m# 1. content-length has not been explicitly set[39;49;00m
        [90m# 2. the body is a file or iterable, but not a str or bytes-like[39;49;00m
        [90m# 3. Transfer-Encoding has NOT been explicitly set by the caller[39;49;00m
    
        [94mif[39;49;00m [33m'[39;49;00m[33mcontent-length[39;49;00m[33m'[39;49;00m [95mnot[39;49;00m [95min[39;49;00m header_names:
            [90m# only chunk body if not explicitly set for backwards[39;49;00m
            [90m# compatibility, assuming the client code is already handling the[39;49;00m
            [90m# chunking[39;49;00m
            [94mif[39;49;00m [33m'[39;49;00m[33mtransfer-encoding[39;49;00m[33m'[39;49;00m [95mnot[39;49;00m [95min[39;49;00m header_names:
                [90m# if content-length cannot be automatically determined, fall[39;49;00m
                [90m# back to chunked encoding[39;49;00m
                encode_chunked = [94mFalse[39;49;00m
                content_length = [96mself[39;49;00m._get_content_length(body, method)
                [94mif[39;49;00m content_length [95mis[39;49;00m [94mNone[39;49;00m:
                    [94mif[39;49;00m body [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                        [94mif[39;49;00m [96mself[39;49;00m.debuglevel > [94m0[39;49;00m:
                            [96mprint[39;49;00m([33m'[39;49;00m[33mUnable to determine size of [39;49;00m[33m%r[39;49;00m[33m'[39;49;00m % body)
                        encode_chunked = [94mTrue[39;49;00m
                        [96mself[39;49;00m.putheader([33m'[39;49;00m[33mTransfer-Encoding[39;49;00m[33m'[39;49;00m, [33m'[39;49;00m[33mchunked[39;49;00m[33m'[39;49;00m)
                [94melse[39;49;00m:
                    [96mself[39;49;00m.putheader([33m'[39;49;00m[33mContent-Length[39;49;00m[33m'[39;49;00m, [96mstr[39;49;00m(content_length))
        [94melse[39;49;00m:
            encode_chunked = [94mFalse[39;49;00m
    
        [94mfor[39;49;00m hdr, value [95min[39;49;00m headers.items():
            [96mself[39;49;00m.putheader(hdr, value)
        [94mif[39;49;00m [96misinstance[39;49;00m(body, [96mstr[39;49;00m):
            [90m# RFC 2616 Section 3.7.1 says that text default has a[39;49;00m
            [90m# default charset of iso-8859-1.[39;49;00m
            body = _encode(body, [33m'[39;49;00m[33mbody[39;49;00m[33m'[39;49;00m)
>       [96mself[39;49;00m.endheaders(body, encode_chunked=encode_chunked)

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:1328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd15080d570>
message_body = None

    [94mdef[39;49;00m [92mendheaders[39;49;00m([96mself[39;49;00m, message_body=[94mNone[39;49;00m, *, encode_chunked=[94mFalse[39;49;00m):
    [90m    [39;49;00m[33m"""Indicate that the last header line has been sent to the server.[39;49;00m
    [33m[39;49;00m
    [33m    This method sends the request to the server.  The optional message_body[39;49;00m
    [33m    argument can be used to pass a message body associated with the[39;49;00m
    [33m    request.[39;49;00m
    [33m    """[39;49;00m
        [94mif[39;49;00m [96mself[39;49;00m.__state == _CS_REQ_STARTED:
            [96mself[39;49;00m.__state = _CS_REQ_SENT
        [94melse[39;49;00m:
            [94mraise[39;49;00m CannotSendHeader()
>       [96mself[39;49;00m._send_output(message_body, encode_chunked=encode_chunked)

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:1277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd15080d570>
message_body = None, encode_chunked = False

    [94mdef[39;49;00m [92m_send_output[39;49;00m([96mself[39;49;00m, message_body=[94mNone[39;49;00m, encode_chunked=[94mFalse[39;49;00m):
    [90m    [39;49;00m[33m"""Send the currently buffered request and clear the buffer.[39;49;00m
    [33m[39;49;00m
    [33m    Appends an extra \\r\\n to the buffer.[39;49;00m
    [33m    A message_body may be specified, to be appended to the request.[39;49;00m
    [33m    """[39;49;00m
        [96mself[39;49;00m._buffer.extend(([33mb[39;49;00m[33m"[39;49;00m[33m"[39;49;00m, [33mb[39;49;00m[33m"[39;49;00m[33m"[39;49;00m))
        msg = [33mb[39;49;00m[33m"[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m"[39;49;00m.join([96mself[39;49;00m._buffer)
        [94mdel[39;49;00m [96mself[39;49;00m._buffer[:]
>       [96mself[39;49;00m.send(msg)

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:1037: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd15080d570>
data = b'GET /api/v2/messages HTTP/1.1\r\nHost: localhost:8025\r\nUser-Agent: python-requests/2.27.1\r\nAccept-Encoding: gzip, deflate\r\nAccept: */*\r\nConnection: keep-alive\r\n\r\n'

    [94mdef[39;49;00m [92msend[39;49;00m([96mself[39;49;00m, data):
    [90m    [39;49;00m[33m"""Send `data' to the server.[39;49;00m
    [33m    ``data`` can be a string object, a bytes object, an array object, a[39;49;00m
    [33m    file-like object that supports a .read() method, or an iterable object.[39;49;00m
    [33m    """[39;49;00m
    
        [94mif[39;49;00m [96mself[39;49;00m.sock [95mis[39;49;00m [94mNone[39;49;00m:
            [94mif[39;49;00m [96mself[39;49;00m.auto_open:
>               [96mself[39;49;00m.connect()

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd15080d570>

    [94mdef[39;49;00m [92mconnect[39;49;00m([96mself[39;49;00m):
>       conn = [96mself[39;49;00m._new_conn()

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connection.py[0m:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd15080d570>

    [94mdef[39;49;00m [92m_new_conn[39;49;00m([96mself[39;49;00m):
    [90m    [39;49;00m[33m"""Establish a socket connection and set nodelay settings on it.[39;49;00m
    [33m[39;49;00m
    [33m    :return: New socket connection.[39;49;00m
    [33m    """[39;49;00m
        extra_kw = {}
        [94mif[39;49;00m [96mself[39;49;00m.source_address:
            extra_kw[[33m"[39;49;00m[33msource_address[39;49;00m[33m"[39;49;00m] = [96mself[39;49;00m.source_address
    
        [94mif[39;49;00m [96mself[39;49;00m.socket_options:
            extra_kw[[33m"[39;49;00m[33msocket_options[39;49;00m[33m"[39;49;00m] = [96mself[39;49;00m.socket_options
    
        [94mtry[39;49;00m:
            conn = connection.create_connection(
                ([96mself[39;49;00m._dns_host, [96mself[39;49;00m.port), [96mself[39;49;00m.timeout, **extra_kw
            )
    
        [94mexcept[39;49;00m SocketTimeout:
            [94mraise[39;49;00m ConnectTimeoutError(
                [96mself[39;49;00m,
                [33m"[39;49;00m[33mConnection to [39;49;00m[33m%s[39;49;00m[33m timed out. (connect timeout=[39;49;00m[33m%s[39;49;00m[33m)[39;49;00m[33m"[39;49;00m
                % ([96mself[39;49;00m.host, [96mself[39;49;00m.timeout),
            )
    
        [94mexcept[39;49;00m SocketError [94mas[39;49;00m e:
>           [94mraise[39;49;00m NewConnectionError(
                [96mself[39;49;00m, [33m"[39;49;00m[33mFailed to establish a new connection: [39;49;00m[33m%s[39;49;00m[33m"[39;49;00m % e
            )
[1m[31mE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x7fd15080d570>: Failed to establish a new connection: [Errno 111] Connection refused[0m

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connection.py[0m:186: NewConnectionError

[33mDuring handling of the above exception, another exception occurred:[0m

self = <requests.adapters.HTTPAdapter object at 0x7fd15080d300>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    [94mdef[39;49;00m [92msend[39;49;00m([96mself[39;49;00m, request, stream=[94mFalse[39;49;00m, timeout=[94mNone[39;49;00m, verify=[94mTrue[39;49;00m, cert=[94mNone[39;49;00m, proxies=[94mNone[39;49;00m):
    [90m    [39;49;00m[33m"""Sends PreparedRequest object. Returns Response object.[39;49;00m
    [33m[39;49;00m
    [33m    :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[39;49;00m
    [33m    :param stream: (optional) Whether to stream the request content.[39;49;00m
    [33m    :param timeout: (optional) How long to wait for the server to send[39;49;00m
    [33m        data before giving up, as a float, or a :ref:`(connect timeout,[39;49;00m
    [33m        read timeout) <timeouts>` tuple.[39;49;00m
    [33m    :type timeout: float or tuple or urllib3 Timeout object[39;49;00m
    [33m    :param verify: (optional) Either a boolean, in which case it controls whether[39;49;00m
    [33m        we verify the server's TLS certificate, or a string, in which case it[39;49;00m
    [33m        must be a path to a CA bundle to use[39;49;00m
    [33m    :param cert: (optional) Any user-provided SSL certificate to be trusted.[39;49;00m
    [33m    :param proxies: (optional) The proxies dictionary to apply to the request.[39;49;00m
    [33m    :rtype: requests.Response[39;49;00m
    [33m    """[39;49;00m
    
        [94mtry[39;49;00m:
            conn = [96mself[39;49;00m.get_connection(request.url, proxies)
        [94mexcept[39;49;00m LocationValueError [94mas[39;49;00m e:
            [94mraise[39;49;00m InvalidURL(e, request=request)
    
        [96mself[39;49;00m.cert_verify(conn, request.url, verify, cert)
        url = [96mself[39;49;00m.request_url(request, proxies)
        [96mself[39;49;00m.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = [95mnot[39;49;00m (request.body [95mis[39;49;00m [94mNone[39;49;00m [95mor[39;49;00m [33m'[39;49;00m[33mContent-Length[39;49;00m[33m'[39;49;00m [95min[39;49;00m request.headers)
    
        [94mif[39;49;00m [96misinstance[39;49;00m(timeout, [96mtuple[39;49;00m):
            [94mtry[39;49;00m:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            [94mexcept[39;49;00m [96mValueError[39;49;00m [94mas[39;49;00m e:
                [90m# this may raise a string formatting error.[39;49;00m
                err = ([33m"[39;49;00m[33mInvalid timeout [39;49;00m[33m{}[39;49;00m[33m. Pass a (connect, read) [39;49;00m[33m"[39;49;00m
                       [33m"[39;49;00m[33mtimeout tuple, or a single float to set [39;49;00m[33m"[39;49;00m
                       [33m"[39;49;00m[33mboth timeouts to the same value[39;49;00m[33m"[39;49;00m.format(timeout))
                [94mraise[39;49;00m [96mValueError[39;49;00m(err)
        [94melif[39;49;00m [96misinstance[39;49;00m(timeout, TimeoutSauce):
            [94mpass[39;49;00m
        [94melse[39;49;00m:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        [94mtry[39;49;00m:
            [94mif[39;49;00m [95mnot[39;49;00m chunked:
>               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=[94mFalse[39;49;00m,
                    assert_same_host=[94mFalse[39;49;00m,
                    preload_content=[94mFalse[39;49;00m,
                    decode_content=[94mFalse[39;49;00m,
                    retries=[96mself[39;49;00m.max_retries,
                    timeout=timeout
                )

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/adapters.py[0m:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fd15080dae0>
method = 'GET', url = '/api/v2/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v2/messages', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    [94mdef[39;49;00m [92murlopen[39;49;00m(
        [96mself[39;49;00m,
        method,
        url,
        body=[94mNone[39;49;00m,
        headers=[94mNone[39;49;00m,
        retries=[94mNone[39;49;00m,
        redirect=[94mTrue[39;49;00m,
        assert_same_host=[94mTrue[39;49;00m,
        timeout=_Default,
        pool_timeout=[94mNone[39;49;00m,
        release_conn=[94mNone[39;49;00m,
        chunked=[94mFalse[39;49;00m,
        body_pos=[94mNone[39;49;00m,
        **response_kw
    ):
    [90m    [39;49;00m[33m"""[39;49;00m
    [33m    Get a connection from the pool and perform an HTTP request. This is the[39;49;00m
    [33m    lowest level call for making a request, so you'll need to specify all[39;49;00m
    [33m    the raw details.[39;49;00m
    [33m[39;49;00m
    [33m    .. note::[39;49;00m
    [33m[39;49;00m
    [33m       More commonly, it's appropriate to use a convenience method provided[39;49;00m
    [33m       by :class:`.RequestMethods`, such as :meth:`request`.[39;49;00m
    [33m[39;49;00m
    [33m    .. note::[39;49;00m
    [33m[39;49;00m
    [33m       `release_conn` will only behave as expected if[39;49;00m
    [33m       `preload_content=False` because we want to make[39;49;00m
    [33m       `preload_content=False` the default behaviour someday soon without[39;49;00m
    [33m       breaking backwards compatibility.[39;49;00m
    [33m[39;49;00m
    [33m    :param method:[39;49;00m
    [33m        HTTP request method (such as GET, POST, PUT, etc.)[39;49;00m
    [33m[39;49;00m
    [33m    :param url:[39;49;00m
    [33m        The URL to perform the request on.[39;49;00m
    [33m[39;49;00m
    [33m    :param body:[39;49;00m
    [33m        Data to send in the request body, either :class:`str`, :class:`bytes`,[39;49;00m
    [33m        an iterable of :class:`str`/:class:`bytes`, or a file-like object.[39;49;00m
    [33m[39;49;00m
    [33m    :param headers:[39;49;00m
    [33m        Dictionary of custom headers to send, such as User-Agent,[39;49;00m
    [33m        If-None-Match, etc. If None, pool headers are used. If provided,[39;49;00m
    [33m        these headers completely replace any pool-specific headers.[39;49;00m
    [33m[39;49;00m
    [33m    :param retries:[39;49;00m
    [33m        Configure the number of retries to allow before raising a[39;49;00m
    [33m        :class:`~urllib3.exceptions.MaxRetryError` exception.[39;49;00m
    [33m[39;49;00m
    [33m        Pass ``None`` to retry until you receive a response. Pass a[39;49;00m
    [33m        :class:`~urllib3.util.retry.Retry` object for fine-grained control[39;49;00m
    [33m        over different types of retries.[39;49;00m
    [33m        Pass an integer number to retry connection errors that many times,[39;49;00m
    [33m        but no other types of errors. Pass zero to never retry.[39;49;00m
    [33m[39;49;00m
    [33m        If ``False``, then retries are disabled and any exception is raised[39;49;00m
    [33m        immediately. Also, instead of raising a MaxRetryError on redirects,[39;49;00m
    [33m        the redirect response will be returned.[39;49;00m
    [33m[39;49;00m
    [33m    :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.[39;49;00m
    [33m[39;49;00m
    [33m    :param redirect:[39;49;00m
    [33m        If True, automatically handle redirects (status codes 301, 302,[39;49;00m
    [33m        303, 307, 308). Each redirect counts as a retry. Disabling retries[39;49;00m
    [33m        will disable redirect, too.[39;49;00m
    [33m[39;49;00m
    [33m    :param assert_same_host:[39;49;00m
    [33m        If ``True``, will make sure that the host of the pool requests is[39;49;00m
    [33m        consistent else will raise HostChangedError. When ``False``, you can[39;49;00m
    [33m        use the pool on an HTTP proxy and request foreign hosts.[39;49;00m
    [33m[39;49;00m
    [33m    :param timeout:[39;49;00m
    [33m        If specified, overrides the default timeout for this one[39;49;00m
    [33m        request. It may be a float (in seconds) or an instance of[39;49;00m
    [33m        :class:`urllib3.util.Timeout`.[39;49;00m
    [33m[39;49;00m
    [33m    :param pool_timeout:[39;49;00m
    [33m        If set and the pool is set to block=True, then this method will[39;49;00m
    [33m        block for ``pool_timeout`` seconds and raise EmptyPoolError if no[39;49;00m
    [33m        connection is available within the time period.[39;49;00m
    [33m[39;49;00m
    [33m    :param release_conn:[39;49;00m
    [33m        If False, then the urlopen call will not release the connection[39;49;00m
    [33m        back into the pool once a response is received (but will release if[39;49;00m
    [33m        you read the entire contents of the response such as when[39;49;00m
    [33m        `preload_content=True`). This is useful if you're not preloading[39;49;00m
    [33m        the response's content immediately. You will need to call[39;49;00m
    [33m        ``r.release_conn()`` on the response ``r`` to return the connection[39;49;00m
    [33m        back into the pool. If None, it takes the value of[39;49;00m
    [33m        ``response_kw.get('preload_content', True)``.[39;49;00m
    [33m[39;49;00m
    [33m    :param chunked:[39;49;00m
    [33m        If True, urllib3 will send the body using chunked transfer[39;49;00m
    [33m        encoding. Otherwise, urllib3 will send the body using the standard[39;49;00m
    [33m        content-length form. Defaults to False.[39;49;00m
    [33m[39;49;00m
    [33m    :param int body_pos:[39;49;00m
    [33m        Position to seek to in file-like body in the event of a retry or[39;49;00m
    [33m        redirect. Typically this won't need to be set because urllib3 will[39;49;00m
    [33m        auto-populate the value when needed.[39;49;00m
    [33m[39;49;00m
    [33m    :param \\**response_kw:[39;49;00m
    [33m        Additional parameters are passed to[39;49;00m
    [33m        :meth:`urllib3.response.HTTPResponse.from_httplib`[39;49;00m
    [33m    """[39;49;00m
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        [94mif[39;49;00m headers [95mis[39;49;00m [94mNone[39;49;00m:
            headers = [96mself[39;49;00m.headers
    
        [94mif[39;49;00m [95mnot[39;49;00m [96misinstance[39;49;00m(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=[96mself[39;49;00m.retries)
    
        [94mif[39;49;00m release_conn [95mis[39;49;00m [94mNone[39;49;00m:
            release_conn = response_kw.get([33m"[39;49;00m[33mpreload_content[39;49;00m[33m"[39;49;00m, [94mTrue[39;49;00m)
    
        [90m# Check host[39;49;00m
        [94mif[39;49;00m assert_same_host [95mand[39;49;00m [95mnot[39;49;00m [96mself[39;49;00m.is_same_host(url):
            [94mraise[39;49;00m HostChangedError([96mself[39;49;00m, url, retries)
    
        [90m# Ensure that the URL we're connecting to is properly encoded[39;49;00m
        [94mif[39;49;00m url.startswith([33m"[39;49;00m[33m/[39;49;00m[33m"[39;49;00m):
            url = six.ensure_str(_encode_target(url))
        [94melse[39;49;00m:
            url = six.ensure_str(parsed_url.url)
    
        conn = [94mNone[39;49;00m
    
        [90m# Track whether `conn` needs to be released before[39;49;00m
        [90m# returning/raising/recursing. Update this variable if necessary, and[39;49;00m
        [90m# leave `release_conn` constant throughout the function. That way, if[39;49;00m
        [90m# the function recurses, the original value of `release_conn` will be[39;49;00m
        [90m# passed down into the recursive call, and its value will be respected.[39;49;00m
        [90m#[39;49;00m
        [90m# See issue #651 [1] for details.[39;49;00m
        [90m#[39;49;00m
        [90m# [1] <https://github.com/urllib3/urllib3/issues/651>[39;49;00m
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            [96mself[39;49;00m.proxy, [96mself[39;49;00m.proxy_config, destination_scheme
        )
    
        [90m# Merge the proxy headers. Only done when not using HTTP CONNECT. We[39;49;00m
        [90m# have to copy the headers dict so we can safely change it without those[39;49;00m
        [90m# changes being reflected in anyone else's copy.[39;49;00m
        [94mif[39;49;00m [95mnot[39;49;00m http_tunnel_required:
            headers = headers.copy()
            headers.update([96mself[39;49;00m.proxy_headers)
    
        [90m# Must keep the exception bound to a separate variable or else Python 3[39;49;00m
        [90m# complains about UnboundLocalError.[39;49;00m
        err = [94mNone[39;49;00m
    
        [90m# Keep track of whether we cleanly exited the except block. This[39;49;00m
        [90m# ensures we do proper cleanup in finally.[39;49;00m
        clean_exit = [94mFalse[39;49;00m
    
        [90m# Rewind body position, if needed. Record current position[39;49;00m
        [90m# for future rewinds in the event of a redirect/retry.[39;49;00m
        body_pos = set_file_position(body, body_pos)
    
        [94mtry[39;49;00m:
            [90m# Request a connection from the queue.[39;49;00m
            timeout_obj = [96mself[39;49;00m._get_timeout(timeout)
            conn = [96mself[39;49;00m._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = [96mself[39;49;00m.proxy [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m [95mand[39;49;00m [95mnot[39;49;00m [96mgetattr[39;49;00m(
                conn, [33m"[39;49;00m[33msock[39;49;00m[33m"[39;49;00m, [94mNone[39;49;00m
            )
            [94mif[39;49;00m is_new_proxy_conn [95mand[39;49;00m http_tunnel_required:
                [96mself[39;49;00m._prepare_proxy(conn)
    
            [90m# Make the request on the httplib connection object.[39;49;00m
            httplib_response = [96mself[39;49;00m._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            [90m# If we're going to release the connection in ``finally:``, then[39;49;00m
            [90m# the response doesn't need to know about the connection. Otherwise[39;49;00m
            [90m# it will also try to release it and we'll have a double-release[39;49;00m
            [90m# mess.[39;49;00m
            response_conn = conn [94mif[39;49;00m [95mnot[39;49;00m release_conn [94melse[39;49;00m [94mNone[39;49;00m
    
            [90m# Pass method to Response for length checking[39;49;00m
            response_kw[[33m"[39;49;00m[33mrequest_method[39;49;00m[33m"[39;49;00m] = method
    
            [90m# Import httplib's response into our own wrapper object[39;49;00m
            response = [96mself[39;49;00m.ResponseCls.from_httplib(
                httplib_response,
                pool=[96mself[39;49;00m,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            [90m# Everything went great![39;49;00m
            clean_exit = [94mTrue[39;49;00m
    
        [94mexcept[39;49;00m EmptyPoolError:
            [90m# Didn't get a connection from the pool, no need to clean up[39;49;00m
            clean_exit = [94mTrue[39;49;00m
            release_this_conn = [94mFalse[39;49;00m
            [94mraise[39;49;00m
    
        [94mexcept[39;49;00m (
            [96mTimeoutError[39;49;00m,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) [94mas[39;49;00m e:
            [90m# Discard the connection for these exceptions. It will be[39;49;00m
            [90m# replaced during the next _get_conn() call.[39;49;00m
            clean_exit = [94mFalse[39;49;00m
    
            [94mdef[39;49;00m [92m_is_ssl_error_message_from_http_proxy[39;49;00m(ssl_error):
                [90m# We're trying to detect the message 'WRONG_VERSION_NUMBER' but[39;49;00m
                [90m# SSLErrors are kinda all over the place when it comes to the message,[39;49;00m
                [90m# so we try to cover our bases here![39;49;00m
                message = [33m"[39;49;00m[33m [39;49;00m[33m"[39;49;00m.join(re.split([33m"[39;49;00m[33m[^a-z][39;49;00m[33m"[39;49;00m, [96mstr[39;49;00m(ssl_error).lower()))
                [94mreturn[39;49;00m (
                    [33m"[39;49;00m[33mwrong version number[39;49;00m[33m"[39;49;00m [95min[39;49;00m message [95mor[39;49;00m [33m"[39;49;00m[33munknown protocol[39;49;00m[33m"[39;49;00m [95min[39;49;00m message
                )
    
            [90m# Try to detect a common user error with proxies which is to[39;49;00m
            [90m# set an HTTP proxy to be HTTPS when it should be 'http://'[39;49;00m
            [90m# (ie {'http': 'http://proxy', 'https': 'https://proxy'})[39;49;00m
            [90m# Instead we add a nice error message and point to a URL.[39;49;00m
            [94mif[39;49;00m (
                [96misinstance[39;49;00m(e, BaseSSLError)
                [95mand[39;49;00m [96mself[39;49;00m.proxy
                [95mand[39;49;00m _is_ssl_error_message_from_http_proxy(e)
            ):
                e = ProxyError(
                    [33m"[39;49;00m[33mYour proxy appears to only use HTTP and not HTTPS, [39;49;00m[33m"[39;49;00m
                    [33m"[39;49;00m[33mtry changing your proxy URL to be HTTP. See: [39;49;00m[33m"[39;49;00m
                    [33m"[39;49;00m[33mhttps://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html[39;49;00m[33m"[39;49;00m
                    [33m"[39;49;00m[33m#https-proxy-error-http-proxy[39;49;00m[33m"[39;49;00m,
                    SSLError(e),
                )
            [94melif[39;49;00m [96misinstance[39;49;00m(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            [94melif[39;49;00m [96misinstance[39;49;00m(e, (SocketError, NewConnectionError)) [95mand[39;49;00m [96mself[39;49;00m.proxy:
                e = ProxyError([33m"[39;49;00m[33mCannot connect to proxy.[39;49;00m[33m"[39;49;00m, e)
            [94melif[39;49;00m [96misinstance[39;49;00m(e, (SocketError, HTTPException)):
                e = ProtocolError([33m"[39;49;00m[33mConnection aborted.[39;49;00m[33m"[39;49;00m, e)
    
>           retries = retries.increment(
                method, url, error=e, _pool=[96mself[39;49;00m, _stacktrace=sys.exc_info()[[94m2[39;49;00m]
            )

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connectionpool.py[0m:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v2/messages', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fd15080d570>: Failed to establish a new connection: [Errno 111] Connection refused')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fd15080dae0>
_stacktrace = <traceback object at 0x7fd15066f280>

    [94mdef[39;49;00m [92mincrement[39;49;00m(
        [96mself[39;49;00m,
        method=[94mNone[39;49;00m,
        url=[94mNone[39;49;00m,
        response=[94mNone[39;49;00m,
        error=[94mNone[39;49;00m,
        _pool=[94mNone[39;49;00m,
        _stacktrace=[94mNone[39;49;00m,
    ):
    [90m    [39;49;00m[33m"""Return a new Retry object with incremented retry counters.[39;49;00m
    [33m[39;49;00m
    [33m    :param response: A response object, or None, if the server did not[39;49;00m
    [33m        return a response.[39;49;00m
    [33m    :type response: :class:`~urllib3.response.HTTPResponse`[39;49;00m
    [33m    :param Exception error: An error encountered during the request, or[39;49;00m
    [33m        None if the response was received successfully.[39;49;00m
    [33m[39;49;00m
    [33m    :return: A new ``Retry`` object.[39;49;00m
    [33m    """[39;49;00m
        [94mif[39;49;00m [96mself[39;49;00m.total [95mis[39;49;00m [94mFalse[39;49;00m [95mand[39;49;00m error:
            [90m# Disabled, indicate to re-raise the error.[39;49;00m
            [94mraise[39;49;00m six.reraise([96mtype[39;49;00m(error), error, _stacktrace)
    
        total = [96mself[39;49;00m.total
        [94mif[39;49;00m total [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
            total -= [94m1[39;49;00m
    
        connect = [96mself[39;49;00m.connect
        read = [96mself[39;49;00m.read
        redirect = [96mself[39;49;00m.redirect
        status_count = [96mself[39;49;00m.status
        other = [96mself[39;49;00m.other
        cause = [33m"[39;49;00m[33munknown[39;49;00m[33m"[39;49;00m
        status = [94mNone[39;49;00m
        redirect_location = [94mNone[39;49;00m
    
        [94mif[39;49;00m error [95mand[39;49;00m [96mself[39;49;00m._is_connection_error(error):
            [90m# Connect retry?[39;49;00m
            [94mif[39;49;00m connect [95mis[39;49;00m [94mFalse[39;49;00m:
                [94mraise[39;49;00m six.reraise([96mtype[39;49;00m(error), error, _stacktrace)
            [94melif[39;49;00m connect [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                connect -= [94m1[39;49;00m
    
        [94melif[39;49;00m error [95mand[39;49;00m [96mself[39;49;00m._is_read_error(error):
            [90m# Read retry?[39;49;00m
            [94mif[39;49;00m read [95mis[39;49;00m [94mFalse[39;49;00m [95mor[39;49;00m [95mnot[39;49;00m [96mself[39;49;00m._is_method_retryable(method):
                [94mraise[39;49;00m six.reraise([96mtype[39;49;00m(error), error, _stacktrace)
            [94melif[39;49;00m read [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                read -= [94m1[39;49;00m
    
        [94melif[39;49;00m error:
            [90m# Other retry?[39;49;00m
            [94mif[39;49;00m other [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                other -= [94m1[39;49;00m
    
        [94melif[39;49;00m response [95mand[39;49;00m response.get_redirect_location():
            [90m# Redirect retry?[39;49;00m
            [94mif[39;49;00m redirect [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                redirect -= [94m1[39;49;00m
            cause = [33m"[39;49;00m[33mtoo many redirects[39;49;00m[33m"[39;49;00m
            redirect_location = response.get_redirect_location()
            status = response.status
    
        [94melse[39;49;00m:
            [90m# Incrementing because of a server error like a 500 in[39;49;00m
            [90m# status_forcelist and the given method is in the allowed_methods[39;49;00m
            cause = ResponseError.GENERIC_ERROR
            [94mif[39;49;00m response [95mand[39;49;00m response.status:
                [94mif[39;49;00m status_count [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                    status_count -= [94m1[39;49;00m
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = [96mself[39;49;00m.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = [96mself[39;49;00m.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        [94mif[39;49;00m new_retry.is_exhausted():
>           [94mraise[39;49;00m MaxRetryError(_pool, url, error [95mor[39;49;00m ResponseError(cause))
[1m[31mE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=8025): Max retries exceeded with url: /api/v2/messages (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fd15080d570>: Failed to establish a new connection: [Errno 111] Connection refused'))[0m

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/util/retry.py[0m:592: MaxRetryError

[33mDuring handling of the above exception, another exception occurred:[0m

client = <starlette.testclient.TestClient object at 0x7fd152686ef0>

    [94mdef[39;49;00m [92mtest_verification_email[39;49;00m(client: TestClient) -> [94mNone[39;49;00m:
>       mailhog_email_req = requests.get([33mf[39;49;00m[33m"[39;49;00m[33m{[39;49;00mMAILHOG_URL[33m}[39;49;00m[33m/v2/messages[39;49;00m[33m"[39;49;00m)

[1m[31mtests/api/api_v1/test_auth.py[0m:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/api.py[0m:75: in get
    [94mreturn[39;49;00m request([33m'[39;49;00m[33mget[39;49;00m[33m'[39;49;00m, url, params=params, **kwargs)
[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/api.py[0m:61: in request
    [94mreturn[39;49;00m session.request(method=method, url=url, **kwargs)
[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/sessions.py[0m:529: in request
    resp = [96mself[39;49;00m.send(prep, **send_kwargs)
[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/sessions.py[0m:645: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7fd15080d300>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    [94mdef[39;49;00m [92msend[39;49;00m([96mself[39;49;00m, request, stream=[94mFalse[39;49;00m, timeout=[94mNone[39;49;00m, verify=[94mTrue[39;49;00m, cert=[94mNone[39;49;00m, proxies=[94mNone[39;49;00m):
    [90m    [39;49;00m[33m"""Sends PreparedRequest object. Returns Response object.[39;49;00m
    [33m[39;49;00m
    [33m    :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[39;49;00m
    [33m    :param stream: (optional) Whether to stream the request content.[39;49;00m
    [33m    :param timeout: (optional) How long to wait for the server to send[39;49;00m
    [33m        data before giving up, as a float, or a :ref:`(connect timeout,[39;49;00m
    [33m        read timeout) <timeouts>` tuple.[39;49;00m
    [33m    :type timeout: float or tuple or urllib3 Timeout object[39;49;00m
    [33m    :param verify: (optional) Either a boolean, in which case it controls whether[39;49;00m
    [33m        we verify the server's TLS certificate, or a string, in which case it[39;49;00m
    [33m        must be a path to a CA bundle to use[39;49;00m
    [33m    :param cert: (optional) Any user-provided SSL certificate to be trusted.[39;49;00m
    [33m    :param proxies: (optional) The proxies dictionary to apply to the request.[39;49;00m
    [33m    :rtype: requests.Response[39;49;00m
    [33m    """[39;49;00m
    
        [94mtry[39;49;00m:
            conn = [96mself[39;49;00m.get_connection(request.url, proxies)
        [94mexcept[39;49;00m LocationValueError [94mas[39;49;00m e:
            [94mraise[39;49;00m InvalidURL(e, request=request)
    
        [96mself[39;49;00m.cert_verify(conn, request.url, verify, cert)
        url = [96mself[39;49;00m.request_url(request, proxies)
        [96mself[39;49;00m.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = [95mnot[39;49;00m (request.body [95mis[39;49;00m [94mNone[39;49;00m [95mor[39;49;00m [33m'[39;49;00m[33mContent-Length[39;49;00m[33m'[39;49;00m [95min[39;49;00m request.headers)
    
        [94mif[39;49;00m [96misinstance[39;49;00m(timeout, [96mtuple[39;49;00m):
            [94mtry[39;49;00m:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            [94mexcept[39;49;00m [96mValueError[39;49;00m [94mas[39;49;00m e:
                [90m# this may raise a string formatting error.[39;49;00m
                err = ([33m"[39;49;00m[33mInvalid timeout [39;49;00m[33m{}[39;49;00m[33m. Pass a (connect, read) [39;49;00m[33m"[39;49;00m
                       [33m"[39;49;00m[33mtimeout tuple, or a single float to set [39;49;00m[33m"[39;49;00m
                       [33m"[39;49;00m[33mboth timeouts to the same value[39;49;00m[33m"[39;49;00m.format(timeout))
                [94mraise[39;49;00m [96mValueError[39;49;00m(err)
        [94melif[39;49;00m [96misinstance[39;49;00m(timeout, TimeoutSauce):
            [94mpass[39;49;00m
        [94melse[39;49;00m:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        [94mtry[39;49;00m:
            [94mif[39;49;00m [95mnot[39;49;00m chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=[94mFalse[39;49;00m,
                    assert_same_host=[94mFalse[39;49;00m,
                    preload_content=[94mFalse[39;49;00m,
                    decode_content=[94mFalse[39;49;00m,
                    retries=[96mself[39;49;00m.max_retries,
                    timeout=timeout
                )
    
            [90m# Send the request.[39;49;00m
            [94melse[39;49;00m:
                [94mif[39;49;00m [96mhasattr[39;49;00m(conn, [33m'[39;49;00m[33mproxy_pool[39;49;00m[33m'[39;49;00m):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                [94mtry[39;49;00m:
                    skip_host = [33m'[39;49;00m[33mHost[39;49;00m[33m'[39;49;00m [95min[39;49;00m request.headers
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=[94mTrue[39;49;00m,
                                        skip_host=skip_host)
    
                    [94mfor[39;49;00m header, value [95min[39;49;00m request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    [94mfor[39;49;00m i [95min[39;49;00m request.body:
                        low_conn.send([96mhex[39;49;00m([96mlen[39;49;00m(i))[[94m2[39;49;00m:].encode([33m'[39;49;00m[33mutf-8[39;49;00m[33m'[39;49;00m))
                        low_conn.send([33mb[39;49;00m[33m'[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m'[39;49;00m)
                        low_conn.send(i)
                        low_conn.send([33mb[39;49;00m[33m'[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m'[39;49;00m)
                    low_conn.send([33mb[39;49;00m[33m'[39;49;00m[33m0[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m'[39;49;00m)
    
                    [90m# Receive the response from the server[39;49;00m
                    [94mtry[39;49;00m:
                        [90m# For Python 2.7, use buffering of HTTP responses[39;49;00m
                        r = low_conn.getresponse(buffering=[94mTrue[39;49;00m)
                    [94mexcept[39;49;00m [96mTypeError[39;49;00m:
                        [90m# For compatibility with Python 3.3+[39;49;00m
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=[94mFalse[39;49;00m,
                        decode_content=[94mFalse[39;49;00m
                    )
                [94mexcept[39;49;00m:
                    [90m# If we hit any problems here, clean up the connection.[39;49;00m
                    [90m# Then, reraise so that we can handle the actual exception.[39;49;00m
                    low_conn.close()
                    [94mraise[39;49;00m
    
        [94mexcept[39;49;00m (ProtocolError, socket.error) [94mas[39;49;00m err:
            [94mraise[39;49;00m [96mConnectionError[39;49;00m(err, request=request)
    
        [94mexcept[39;49;00m MaxRetryError [94mas[39;49;00m e:
            [94mif[39;49;00m [96misinstance[39;49;00m(e.reason, ConnectTimeoutError):
                [90m# TODO: Remove this in 3.0.0: see #2811[39;49;00m
                [94mif[39;49;00m [95mnot[39;49;00m [96misinstance[39;49;00m(e.reason, NewConnectionError):
                    [94mraise[39;49;00m ConnectTimeout(e, request=request)
    
            [94mif[39;49;00m [96misinstance[39;49;00m(e.reason, ResponseError):
                [94mraise[39;49;00m RetryError(e, request=request)
    
            [94mif[39;49;00m [96misinstance[39;49;00m(e.reason, _ProxyError):
                [94mraise[39;49;00m ProxyError(e, request=request)
    
            [94mif[39;49;00m [96misinstance[39;49;00m(e.reason, _SSLError):
                [90m# This branch is for urllib3 v1.22 and later.[39;49;00m
                [94mraise[39;49;00m SSLError(e, request=request)
    
>           [94mraise[39;49;00m [96mConnectionError[39;49;00m(e, request=request)
[1m[31mE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=8025): Max retries exceeded with url: /api/v2/messages (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fd15080d570>: Failed to establish a new connection: [Errno 111] Connection refused'))[0m

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/adapters.py[0m:519: ConnectionError
[31m[1m_______________________ test_web_session_authentication ________________________[0m

client = <starlette.testclient.TestClient object at 0x7fd152686ef0>
username = None, password = None, remember_me = None

    [94mdef[39;49;00m [92mtest_web_session_authentication[39;49;00m(
        client: TestClient, username=[94mNone[39;49;00m, password=[94mNone[39;49;00m, remember_me=[94mNone[39;49;00m
    ) -> [94mNone[39;49;00m:
        data = {
            [33m"[39;49;00m[33musername[39;49;00m[33m"[39;49;00m: username [95mor[39;49;00m [33m"[39;49;00m[33mtest_student@test.local[39;49;00m[33m"[39;49;00m,
            [33m"[39;49;00m[33mpassword[39;49;00m[33m"[39;49;00m: password [95mor[39;49;00m [33m"[39;49;00m[33mtestold[39;49;00m[33m"[39;49;00m,
            [33m"[39;49;00m[33mremember_me[39;49;00m[33m"[39;49;00m: remember_me [95mor[39;49;00m [94mTrue[39;49;00m,
        }
    
        req = client.post(
            [33mf[39;49;00m[33m"[39;49;00m[33m{[39;49;00msettings.BACKEND_URL_BASE[33m}[39;49;00m[33m{[39;49;00msettings.API_V1_STR[33m}[39;49;00m[33m/auth/web/[39;49;00m[33m"[39;49;00m,
            json=data,
            headers=headers,
        )
    
>       [94massert[39;49;00m req.status_code == [94m200[39;49;00m
[1m[31mE       assert 401 == 200[0m
[1m[31mE         +401[0m
[1m[31mE         -200[0m

[1m[31mtests/api/api_v1/test_auth.py[0m:97: AssertionError
[31m[1m____________________________ test_send_reset_email _____________________________[0m

client = <starlette.testclient.TestClient object at 0x7fd152686ef0>

    [94mdef[39;49;00m [92mtest_send_reset_email[39;49;00m(client: TestClient) -> [94mNone[39;49;00m:
        data = {
            [33m"[39;49;00m[33memail[39;49;00m[33m"[39;49;00m: [33m"[39;49;00m[33mtest_student@test.local[39;49;00m[33m"[39;49;00m,
        }
    
        response = client.post(
            [33mf[39;49;00m[33m"[39;49;00m[33m{[39;49;00msettings.BACKEND_URL_BASE[33m}[39;49;00m[33m{[39;49;00msettings.API_V1_STR[33m}[39;49;00m[33m/auth/password-recovery/[39;49;00m[33m"[39;49;00m,
            headers=headers,
            params=data,
        )
    
>       [94massert[39;49;00m response.status_code == [94m200[39;49;00m
[1m[31mE       assert 404 == 200[0m
[1m[31mE         +404[0m
[1m[31mE         -200[0m

[1m[31mtests/api/api_v1/test_auth.py[0m:129: AssertionError
[31m[1m_____________________________ test_reset_password ______________________________[0m

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>

    [94mdef[39;49;00m [92m_new_conn[39;49;00m([96mself[39;49;00m):
    [90m    [39;49;00m[33m"""Establish a socket connection and set nodelay settings on it.[39;49;00m
    [33m[39;49;00m
    [33m    :return: New socket connection.[39;49;00m
    [33m    """[39;49;00m
        extra_kw = {}
        [94mif[39;49;00m [96mself[39;49;00m.source_address:
            extra_kw[[33m"[39;49;00m[33msource_address[39;49;00m[33m"[39;49;00m] = [96mself[39;49;00m.source_address
    
        [94mif[39;49;00m [96mself[39;49;00m.socket_options:
            extra_kw[[33m"[39;49;00m[33msocket_options[39;49;00m[33m"[39;49;00m] = [96mself[39;49;00m.socket_options
    
        [94mtry[39;49;00m:
>           conn = connection.create_connection(
                ([96mself[39;49;00m._dns_host, [96mself[39;49;00m.port), [96mself[39;49;00m.timeout, **extra_kw
            )

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connection.py[0m:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 8025), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    [94mdef[39;49;00m [92mcreate_connection[39;49;00m(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=[94mNone[39;49;00m,
        socket_options=[94mNone[39;49;00m,
    ):
    [90m    [39;49;00m[33m"""Connect to *address* and return the socket object.[39;49;00m
    [33m[39;49;00m
    [33m    Convenience function.  Connect to *address* (a 2-tuple ``(host,[39;49;00m
    [33m    port)``) and return the socket object.  Passing the optional[39;49;00m
    [33m    *timeout* parameter will set the timeout on the socket instance[39;49;00m
    [33m    before attempting to connect.  If no *timeout* is supplied, the[39;49;00m
    [33m    global default timeout setting returned by :func:`socket.getdefaulttimeout`[39;49;00m
    [33m    is used.  If *source_address* is set it must be a tuple of (host, port)[39;49;00m
    [33m    for the socket to bind as a source address before making the connection.[39;49;00m
    [33m    An host of '' or port 0 tells the OS to use the default.[39;49;00m
    [33m    """[39;49;00m
    
        host, port = address
        [94mif[39;49;00m host.startswith([33m"[39;49;00m[33m[[39;49;00m[33m"[39;49;00m):
            host = host.strip([33m"[39;49;00m[33m[][39;49;00m[33m"[39;49;00m)
        err = [94mNone[39;49;00m
    
        [90m# Using the value from allowed_gai_family() in the context of getaddrinfo lets[39;49;00m
        [90m# us select whether to work with IPv4 DNS records, IPv6 records, or both.[39;49;00m
        [90m# The original create_connection function always returns all records.[39;49;00m
        family = allowed_gai_family()
    
        [94mtry[39;49;00m:
            host.encode([33m"[39;49;00m[33midna[39;49;00m[33m"[39;49;00m)
        [94mexcept[39;49;00m [96mUnicodeError[39;49;00m:
            [94mreturn[39;49;00m six.raise_from(
                LocationParseError([33mu[39;49;00m[33m"[39;49;00m[33m'[39;49;00m[33m%s[39;49;00m[33m'[39;49;00m[33m, label empty or too long[39;49;00m[33m"[39;49;00m % host), [94mNone[39;49;00m
            )
    
        [94mfor[39;49;00m res [95min[39;49;00m socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = [94mNone[39;49;00m
            [94mtry[39;49;00m:
                sock = socket.socket(af, socktype, proto)
    
                [90m# If provided, set socket level options before connecting.[39;49;00m
                _set_socket_options(sock, socket_options)
    
                [94mif[39;49;00m timeout [95mis[39;49;00m [95mnot[39;49;00m socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                [94mif[39;49;00m source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                [94mreturn[39;49;00m sock
    
            [94mexcept[39;49;00m socket.error [94mas[39;49;00m e:
                err = e
                [94mif[39;49;00m sock [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                    sock.close()
                    sock = [94mNone[39;49;00m
    
        [94mif[39;49;00m err [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
>           [94mraise[39;49;00m err

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/util/connection.py[0m:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 8025), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    [94mdef[39;49;00m [92mcreate_connection[39;49;00m(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=[94mNone[39;49;00m,
        socket_options=[94mNone[39;49;00m,
    ):
    [90m    [39;49;00m[33m"""Connect to *address* and return the socket object.[39;49;00m
    [33m[39;49;00m
    [33m    Convenience function.  Connect to *address* (a 2-tuple ``(host,[39;49;00m
    [33m    port)``) and return the socket object.  Passing the optional[39;49;00m
    [33m    *timeout* parameter will set the timeout on the socket instance[39;49;00m
    [33m    before attempting to connect.  If no *timeout* is supplied, the[39;49;00m
    [33m    global default timeout setting returned by :func:`socket.getdefaulttimeout`[39;49;00m
    [33m    is used.  If *source_address* is set it must be a tuple of (host, port)[39;49;00m
    [33m    for the socket to bind as a source address before making the connection.[39;49;00m
    [33m    An host of '' or port 0 tells the OS to use the default.[39;49;00m
    [33m    """[39;49;00m
    
        host, port = address
        [94mif[39;49;00m host.startswith([33m"[39;49;00m[33m[[39;49;00m[33m"[39;49;00m):
            host = host.strip([33m"[39;49;00m[33m[][39;49;00m[33m"[39;49;00m)
        err = [94mNone[39;49;00m
    
        [90m# Using the value from allowed_gai_family() in the context of getaddrinfo lets[39;49;00m
        [90m# us select whether to work with IPv4 DNS records, IPv6 records, or both.[39;49;00m
        [90m# The original create_connection function always returns all records.[39;49;00m
        family = allowed_gai_family()
    
        [94mtry[39;49;00m:
            host.encode([33m"[39;49;00m[33midna[39;49;00m[33m"[39;49;00m)
        [94mexcept[39;49;00m [96mUnicodeError[39;49;00m:
            [94mreturn[39;49;00m six.raise_from(
                LocationParseError([33mu[39;49;00m[33m"[39;49;00m[33m'[39;49;00m[33m%s[39;49;00m[33m'[39;49;00m[33m, label empty or too long[39;49;00m[33m"[39;49;00m % host), [94mNone[39;49;00m
            )
    
        [94mfor[39;49;00m res [95min[39;49;00m socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = [94mNone[39;49;00m
            [94mtry[39;49;00m:
                sock = socket.socket(af, socktype, proto)
    
                [90m# If provided, set socket level options before connecting.[39;49;00m
                _set_socket_options(sock, socket_options)
    
                [94mif[39;49;00m timeout [95mis[39;49;00m [95mnot[39;49;00m socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                [94mif[39;49;00m source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
[1m[31mE               ConnectionRefusedError: [Errno 111] Connection refused[0m

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/util/connection.py[0m:85: ConnectionRefusedError

[33mDuring handling of the above exception, another exception occurred:[0m

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fd1506e8c10>
method = 'GET', url = '/api/v2/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v2/messages', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    [94mdef[39;49;00m [92murlopen[39;49;00m(
        [96mself[39;49;00m,
        method,
        url,
        body=[94mNone[39;49;00m,
        headers=[94mNone[39;49;00m,
        retries=[94mNone[39;49;00m,
        redirect=[94mTrue[39;49;00m,
        assert_same_host=[94mTrue[39;49;00m,
        timeout=_Default,
        pool_timeout=[94mNone[39;49;00m,
        release_conn=[94mNone[39;49;00m,
        chunked=[94mFalse[39;49;00m,
        body_pos=[94mNone[39;49;00m,
        **response_kw
    ):
    [90m    [39;49;00m[33m"""[39;49;00m
    [33m    Get a connection from the pool and perform an HTTP request. This is the[39;49;00m
    [33m    lowest level call for making a request, so you'll need to specify all[39;49;00m
    [33m    the raw details.[39;49;00m
    [33m[39;49;00m
    [33m    .. note::[39;49;00m
    [33m[39;49;00m
    [33m       More commonly, it's appropriate to use a convenience method provided[39;49;00m
    [33m       by :class:`.RequestMethods`, such as :meth:`request`.[39;49;00m
    [33m[39;49;00m
    [33m    .. note::[39;49;00m
    [33m[39;49;00m
    [33m       `release_conn` will only behave as expected if[39;49;00m
    [33m       `preload_content=False` because we want to make[39;49;00m
    [33m       `preload_content=False` the default behaviour someday soon without[39;49;00m
    [33m       breaking backwards compatibility.[39;49;00m
    [33m[39;49;00m
    [33m    :param method:[39;49;00m
    [33m        HTTP request method (such as GET, POST, PUT, etc.)[39;49;00m
    [33m[39;49;00m
    [33m    :param url:[39;49;00m
    [33m        The URL to perform the request on.[39;49;00m
    [33m[39;49;00m
    [33m    :param body:[39;49;00m
    [33m        Data to send in the request body, either :class:`str`, :class:`bytes`,[39;49;00m
    [33m        an iterable of :class:`str`/:class:`bytes`, or a file-like object.[39;49;00m
    [33m[39;49;00m
    [33m    :param headers:[39;49;00m
    [33m        Dictionary of custom headers to send, such as User-Agent,[39;49;00m
    [33m        If-None-Match, etc. If None, pool headers are used. If provided,[39;49;00m
    [33m        these headers completely replace any pool-specific headers.[39;49;00m
    [33m[39;49;00m
    [33m    :param retries:[39;49;00m
    [33m        Configure the number of retries to allow before raising a[39;49;00m
    [33m        :class:`~urllib3.exceptions.MaxRetryError` exception.[39;49;00m
    [33m[39;49;00m
    [33m        Pass ``None`` to retry until you receive a response. Pass a[39;49;00m
    [33m        :class:`~urllib3.util.retry.Retry` object for fine-grained control[39;49;00m
    [33m        over different types of retries.[39;49;00m
    [33m        Pass an integer number to retry connection errors that many times,[39;49;00m
    [33m        but no other types of errors. Pass zero to never retry.[39;49;00m
    [33m[39;49;00m
    [33m        If ``False``, then retries are disabled and any exception is raised[39;49;00m
    [33m        immediately. Also, instead of raising a MaxRetryError on redirects,[39;49;00m
    [33m        the redirect response will be returned.[39;49;00m
    [33m[39;49;00m
    [33m    :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.[39;49;00m
    [33m[39;49;00m
    [33m    :param redirect:[39;49;00m
    [33m        If True, automatically handle redirects (status codes 301, 302,[39;49;00m
    [33m        303, 307, 308). Each redirect counts as a retry. Disabling retries[39;49;00m
    [33m        will disable redirect, too.[39;49;00m
    [33m[39;49;00m
    [33m    :param assert_same_host:[39;49;00m
    [33m        If ``True``, will make sure that the host of the pool requests is[39;49;00m
    [33m        consistent else will raise HostChangedError. When ``False``, you can[39;49;00m
    [33m        use the pool on an HTTP proxy and request foreign hosts.[39;49;00m
    [33m[39;49;00m
    [33m    :param timeout:[39;49;00m
    [33m        If specified, overrides the default timeout for this one[39;49;00m
    [33m        request. It may be a float (in seconds) or an instance of[39;49;00m
    [33m        :class:`urllib3.util.Timeout`.[39;49;00m
    [33m[39;49;00m
    [33m    :param pool_timeout:[39;49;00m
    [33m        If set and the pool is set to block=True, then this method will[39;49;00m
    [33m        block for ``pool_timeout`` seconds and raise EmptyPoolError if no[39;49;00m
    [33m        connection is available within the time period.[39;49;00m
    [33m[39;49;00m
    [33m    :param release_conn:[39;49;00m
    [33m        If False, then the urlopen call will not release the connection[39;49;00m
    [33m        back into the pool once a response is received (but will release if[39;49;00m
    [33m        you read the entire contents of the response such as when[39;49;00m
    [33m        `preload_content=True`). This is useful if you're not preloading[39;49;00m
    [33m        the response's content immediately. You will need to call[39;49;00m
    [33m        ``r.release_conn()`` on the response ``r`` to return the connection[39;49;00m
    [33m        back into the pool. If None, it takes the value of[39;49;00m
    [33m        ``response_kw.get('preload_content', True)``.[39;49;00m
    [33m[39;49;00m
    [33m    :param chunked:[39;49;00m
    [33m        If True, urllib3 will send the body using chunked transfer[39;49;00m
    [33m        encoding. Otherwise, urllib3 will send the body using the standard[39;49;00m
    [33m        content-length form. Defaults to False.[39;49;00m
    [33m[39;49;00m
    [33m    :param int body_pos:[39;49;00m
    [33m        Position to seek to in file-like body in the event of a retry or[39;49;00m
    [33m        redirect. Typically this won't need to be set because urllib3 will[39;49;00m
    [33m        auto-populate the value when needed.[39;49;00m
    [33m[39;49;00m
    [33m    :param \\**response_kw:[39;49;00m
    [33m        Additional parameters are passed to[39;49;00m
    [33m        :meth:`urllib3.response.HTTPResponse.from_httplib`[39;49;00m
    [33m    """[39;49;00m
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        [94mif[39;49;00m headers [95mis[39;49;00m [94mNone[39;49;00m:
            headers = [96mself[39;49;00m.headers
    
        [94mif[39;49;00m [95mnot[39;49;00m [96misinstance[39;49;00m(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=[96mself[39;49;00m.retries)
    
        [94mif[39;49;00m release_conn [95mis[39;49;00m [94mNone[39;49;00m:
            release_conn = response_kw.get([33m"[39;49;00m[33mpreload_content[39;49;00m[33m"[39;49;00m, [94mTrue[39;49;00m)
    
        [90m# Check host[39;49;00m
        [94mif[39;49;00m assert_same_host [95mand[39;49;00m [95mnot[39;49;00m [96mself[39;49;00m.is_same_host(url):
            [94mraise[39;49;00m HostChangedError([96mself[39;49;00m, url, retries)
    
        [90m# Ensure that the URL we're connecting to is properly encoded[39;49;00m
        [94mif[39;49;00m url.startswith([33m"[39;49;00m[33m/[39;49;00m[33m"[39;49;00m):
            url = six.ensure_str(_encode_target(url))
        [94melse[39;49;00m:
            url = six.ensure_str(parsed_url.url)
    
        conn = [94mNone[39;49;00m
    
        [90m# Track whether `conn` needs to be released before[39;49;00m
        [90m# returning/raising/recursing. Update this variable if necessary, and[39;49;00m
        [90m# leave `release_conn` constant throughout the function. That way, if[39;49;00m
        [90m# the function recurses, the original value of `release_conn` will be[39;49;00m
        [90m# passed down into the recursive call, and its value will be respected.[39;49;00m
        [90m#[39;49;00m
        [90m# See issue #651 [1] for details.[39;49;00m
        [90m#[39;49;00m
        [90m# [1] <https://github.com/urllib3/urllib3/issues/651>[39;49;00m
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            [96mself[39;49;00m.proxy, [96mself[39;49;00m.proxy_config, destination_scheme
        )
    
        [90m# Merge the proxy headers. Only done when not using HTTP CONNECT. We[39;49;00m
        [90m# have to copy the headers dict so we can safely change it without those[39;49;00m
        [90m# changes being reflected in anyone else's copy.[39;49;00m
        [94mif[39;49;00m [95mnot[39;49;00m http_tunnel_required:
            headers = headers.copy()
            headers.update([96mself[39;49;00m.proxy_headers)
    
        [90m# Must keep the exception bound to a separate variable or else Python 3[39;49;00m
        [90m# complains about UnboundLocalError.[39;49;00m
        err = [94mNone[39;49;00m
    
        [90m# Keep track of whether we cleanly exited the except block. This[39;49;00m
        [90m# ensures we do proper cleanup in finally.[39;49;00m
        clean_exit = [94mFalse[39;49;00m
    
        [90m# Rewind body position, if needed. Record current position[39;49;00m
        [90m# for future rewinds in the event of a redirect/retry.[39;49;00m
        body_pos = set_file_position(body, body_pos)
    
        [94mtry[39;49;00m:
            [90m# Request a connection from the queue.[39;49;00m
            timeout_obj = [96mself[39;49;00m._get_timeout(timeout)
            conn = [96mself[39;49;00m._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = [96mself[39;49;00m.proxy [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m [95mand[39;49;00m [95mnot[39;49;00m [96mgetattr[39;49;00m(
                conn, [33m"[39;49;00m[33msock[39;49;00m[33m"[39;49;00m, [94mNone[39;49;00m
            )
            [94mif[39;49;00m is_new_proxy_conn [95mand[39;49;00m http_tunnel_required:
                [96mself[39;49;00m._prepare_proxy(conn)
    
            [90m# Make the request on the httplib connection object.[39;49;00m
>           httplib_response = [96mself[39;49;00m._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connectionpool.py[0m:703: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fd1506e8c10>
conn = <urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>
method = 'GET', url = '/api/v2/messages'
timeout = Timeout(connect=None, read=None, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'}}
timeout_obj = Timeout(connect=None, read=None, total=None)

    [94mdef[39;49;00m [92m_make_request[39;49;00m(
        [96mself[39;49;00m, conn, method, url, timeout=_Default, chunked=[94mFalse[39;49;00m, **httplib_request_kw
    ):
    [90m    [39;49;00m[33m"""[39;49;00m
    [33m    Perform a request on a given urllib connection object taken from our[39;49;00m
    [33m    pool.[39;49;00m
    [33m[39;49;00m
    [33m    :param conn:[39;49;00m
    [33m        a connection from one of our connection pools[39;49;00m
    [33m[39;49;00m
    [33m    :param timeout:[39;49;00m
    [33m        Socket timeout in seconds for the request. This can be a[39;49;00m
    [33m        float or integer, which will set the same timeout value for[39;49;00m
    [33m        the socket connect and the socket read, or an instance of[39;49;00m
    [33m        :class:`urllib3.util.Timeout`, which gives you more fine-grained[39;49;00m
    [33m        control over your timeouts.[39;49;00m
    [33m    """[39;49;00m
        [96mself[39;49;00m.num_requests += [94m1[39;49;00m
    
        timeout_obj = [96mself[39;49;00m._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        [90m# Trigger any extra validation we need to do.[39;49;00m
        [94mtry[39;49;00m:
            [96mself[39;49;00m._validate_conn(conn)
        [94mexcept[39;49;00m (SocketTimeout, BaseSSLError) [94mas[39;49;00m e:
            [90m# Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.[39;49;00m
            [96mself[39;49;00m._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            [94mraise[39;49;00m
    
        [90m# conn.request() calls http.client.*.request, not the method in[39;49;00m
        [90m# urllib3.request. It also calls makefile (recv) on the socket.[39;49;00m
        [94mtry[39;49;00m:
            [94mif[39;49;00m chunked:
                conn.request_chunked(method, url, **httplib_request_kw)
            [94melse[39;49;00m:
>               conn.request(method, url, **httplib_request_kw)

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connectionpool.py[0m:398: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>
method = 'GET', url = '/api/v2/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'}

    [94mdef[39;49;00m [92mrequest[39;49;00m([96mself[39;49;00m, method, url, body=[94mNone[39;49;00m, headers=[94mNone[39;49;00m):
        [94mif[39;49;00m headers [95mis[39;49;00m [94mNone[39;49;00m:
            headers = {}
        [94melse[39;49;00m:
            [90m# Avoid modifying the headers passed into .request()[39;49;00m
            headers = headers.copy()
        [94mif[39;49;00m [33m"[39;49;00m[33muser-agent[39;49;00m[33m"[39;49;00m [95mnot[39;49;00m [95min[39;49;00m (six.ensure_str(k.lower()) [94mfor[39;49;00m k [95min[39;49;00m headers):
            headers[[33m"[39;49;00m[33mUser-Agent[39;49;00m[33m"[39;49;00m] = _get_default_user_agent()
>       [96msuper[39;49;00m(HTTPConnection, [96mself[39;49;00m).request(method, url, body=body, headers=headers)

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connection.py[0m:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>
method = 'GET', url = '/api/v2/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'}

    [94mdef[39;49;00m [92mrequest[39;49;00m([96mself[39;49;00m, method, url, body=[94mNone[39;49;00m, headers={}, *,
                encode_chunked=[94mFalse[39;49;00m):
    [90m    [39;49;00m[33m"""Send a complete request to the server."""[39;49;00m
>       [96mself[39;49;00m._send_request(method, url, body, headers, encode_chunked)

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:1282: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>
method = 'GET', url = '/api/v2/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'}
encode_chunked = False

    [94mdef[39;49;00m [92m_send_request[39;49;00m([96mself[39;49;00m, method, url, body, headers, encode_chunked):
        [90m# Honor explicitly requested Host: and Accept-Encoding: headers.[39;49;00m
        header_names = [96mfrozenset[39;49;00m(k.lower() [94mfor[39;49;00m k [95min[39;49;00m headers)
        skips = {}
        [94mif[39;49;00m [33m'[39;49;00m[33mhost[39;49;00m[33m'[39;49;00m [95min[39;49;00m header_names:
            skips[[33m'[39;49;00m[33mskip_host[39;49;00m[33m'[39;49;00m] = [94m1[39;49;00m
        [94mif[39;49;00m [33m'[39;49;00m[33maccept-encoding[39;49;00m[33m'[39;49;00m [95min[39;49;00m header_names:
            skips[[33m'[39;49;00m[33mskip_accept_encoding[39;49;00m[33m'[39;49;00m] = [94m1[39;49;00m
    
        [96mself[39;49;00m.putrequest(method, url, **skips)
    
        [90m# chunked encoding will happen if HTTP/1.1 is used and either[39;49;00m
        [90m# the caller passes encode_chunked=True or the following[39;49;00m
        [90m# conditions hold:[39;49;00m
        [90m# 1. content-length has not been explicitly set[39;49;00m
        [90m# 2. the body is a file or iterable, but not a str or bytes-like[39;49;00m
        [90m# 3. Transfer-Encoding has NOT been explicitly set by the caller[39;49;00m
    
        [94mif[39;49;00m [33m'[39;49;00m[33mcontent-length[39;49;00m[33m'[39;49;00m [95mnot[39;49;00m [95min[39;49;00m header_names:
            [90m# only chunk body if not explicitly set for backwards[39;49;00m
            [90m# compatibility, assuming the client code is already handling the[39;49;00m
            [90m# chunking[39;49;00m
            [94mif[39;49;00m [33m'[39;49;00m[33mtransfer-encoding[39;49;00m[33m'[39;49;00m [95mnot[39;49;00m [95min[39;49;00m header_names:
                [90m# if content-length cannot be automatically determined, fall[39;49;00m
                [90m# back to chunked encoding[39;49;00m
                encode_chunked = [94mFalse[39;49;00m
                content_length = [96mself[39;49;00m._get_content_length(body, method)
                [94mif[39;49;00m content_length [95mis[39;49;00m [94mNone[39;49;00m:
                    [94mif[39;49;00m body [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                        [94mif[39;49;00m [96mself[39;49;00m.debuglevel > [94m0[39;49;00m:
                            [96mprint[39;49;00m([33m'[39;49;00m[33mUnable to determine size of [39;49;00m[33m%r[39;49;00m[33m'[39;49;00m % body)
                        encode_chunked = [94mTrue[39;49;00m
                        [96mself[39;49;00m.putheader([33m'[39;49;00m[33mTransfer-Encoding[39;49;00m[33m'[39;49;00m, [33m'[39;49;00m[33mchunked[39;49;00m[33m'[39;49;00m)
                [94melse[39;49;00m:
                    [96mself[39;49;00m.putheader([33m'[39;49;00m[33mContent-Length[39;49;00m[33m'[39;49;00m, [96mstr[39;49;00m(content_length))
        [94melse[39;49;00m:
            encode_chunked = [94mFalse[39;49;00m
    
        [94mfor[39;49;00m hdr, value [95min[39;49;00m headers.items():
            [96mself[39;49;00m.putheader(hdr, value)
        [94mif[39;49;00m [96misinstance[39;49;00m(body, [96mstr[39;49;00m):
            [90m# RFC 2616 Section 3.7.1 says that text default has a[39;49;00m
            [90m# default charset of iso-8859-1.[39;49;00m
            body = _encode(body, [33m'[39;49;00m[33mbody[39;49;00m[33m'[39;49;00m)
>       [96mself[39;49;00m.endheaders(body, encode_chunked=encode_chunked)

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:1328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>
message_body = None

    [94mdef[39;49;00m [92mendheaders[39;49;00m([96mself[39;49;00m, message_body=[94mNone[39;49;00m, *, encode_chunked=[94mFalse[39;49;00m):
    [90m    [39;49;00m[33m"""Indicate that the last header line has been sent to the server.[39;49;00m
    [33m[39;49;00m
    [33m    This method sends the request to the server.  The optional message_body[39;49;00m
    [33m    argument can be used to pass a message body associated with the[39;49;00m
    [33m    request.[39;49;00m
    [33m    """[39;49;00m
        [94mif[39;49;00m [96mself[39;49;00m.__state == _CS_REQ_STARTED:
            [96mself[39;49;00m.__state = _CS_REQ_SENT
        [94melse[39;49;00m:
            [94mraise[39;49;00m CannotSendHeader()
>       [96mself[39;49;00m._send_output(message_body, encode_chunked=encode_chunked)

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:1277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>
message_body = None, encode_chunked = False

    [94mdef[39;49;00m [92m_send_output[39;49;00m([96mself[39;49;00m, message_body=[94mNone[39;49;00m, encode_chunked=[94mFalse[39;49;00m):
    [90m    [39;49;00m[33m"""Send the currently buffered request and clear the buffer.[39;49;00m
    [33m[39;49;00m
    [33m    Appends an extra \\r\\n to the buffer.[39;49;00m
    [33m    A message_body may be specified, to be appended to the request.[39;49;00m
    [33m    """[39;49;00m
        [96mself[39;49;00m._buffer.extend(([33mb[39;49;00m[33m"[39;49;00m[33m"[39;49;00m, [33mb[39;49;00m[33m"[39;49;00m[33m"[39;49;00m))
        msg = [33mb[39;49;00m[33m"[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m"[39;49;00m.join([96mself[39;49;00m._buffer)
        [94mdel[39;49;00m [96mself[39;49;00m._buffer[:]
>       [96mself[39;49;00m.send(msg)

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:1037: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>
data = b'GET /api/v2/messages HTTP/1.1\r\nHost: localhost:8025\r\nUser-Agent: python-requests/2.27.1\r\nAccept-Encoding: gzip, deflate\r\nAccept: */*\r\nConnection: keep-alive\r\n\r\n'

    [94mdef[39;49;00m [92msend[39;49;00m([96mself[39;49;00m, data):
    [90m    [39;49;00m[33m"""Send `data' to the server.[39;49;00m
    [33m    ``data`` can be a string object, a bytes object, an array object, a[39;49;00m
    [33m    file-like object that supports a .read() method, or an iterable object.[39;49;00m
    [33m    """[39;49;00m
    
        [94mif[39;49;00m [96mself[39;49;00m.sock [95mis[39;49;00m [94mNone[39;49;00m:
            [94mif[39;49;00m [96mself[39;49;00m.auto_open:
>               [96mself[39;49;00m.connect()

[1m[31m/opt/python/3.10.8/lib/python3.10/http/client.py[0m:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>

    [94mdef[39;49;00m [92mconnect[39;49;00m([96mself[39;49;00m):
>       conn = [96mself[39;49;00m._new_conn()

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connection.py[0m:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>

    [94mdef[39;49;00m [92m_new_conn[39;49;00m([96mself[39;49;00m):
    [90m    [39;49;00m[33m"""Establish a socket connection and set nodelay settings on it.[39;49;00m
    [33m[39;49;00m
    [33m    :return: New socket connection.[39;49;00m
    [33m    """[39;49;00m
        extra_kw = {}
        [94mif[39;49;00m [96mself[39;49;00m.source_address:
            extra_kw[[33m"[39;49;00m[33msource_address[39;49;00m[33m"[39;49;00m] = [96mself[39;49;00m.source_address
    
        [94mif[39;49;00m [96mself[39;49;00m.socket_options:
            extra_kw[[33m"[39;49;00m[33msocket_options[39;49;00m[33m"[39;49;00m] = [96mself[39;49;00m.socket_options
    
        [94mtry[39;49;00m:
            conn = connection.create_connection(
                ([96mself[39;49;00m._dns_host, [96mself[39;49;00m.port), [96mself[39;49;00m.timeout, **extra_kw
            )
    
        [94mexcept[39;49;00m SocketTimeout:
            [94mraise[39;49;00m ConnectTimeoutError(
                [96mself[39;49;00m,
                [33m"[39;49;00m[33mConnection to [39;49;00m[33m%s[39;49;00m[33m timed out. (connect timeout=[39;49;00m[33m%s[39;49;00m[33m)[39;49;00m[33m"[39;49;00m
                % ([96mself[39;49;00m.host, [96mself[39;49;00m.timeout),
            )
    
        [94mexcept[39;49;00m SocketError [94mas[39;49;00m e:
>           [94mraise[39;49;00m NewConnectionError(
                [96mself[39;49;00m, [33m"[39;49;00m[33mFailed to establish a new connection: [39;49;00m[33m%s[39;49;00m[33m"[39;49;00m % e
            )
[1m[31mE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>: Failed to establish a new connection: [Errno 111] Connection refused[0m

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connection.py[0m:186: NewConnectionError

[33mDuring handling of the above exception, another exception occurred:[0m

self = <requests.adapters.HTTPAdapter object at 0x7fd1506ea230>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    [94mdef[39;49;00m [92msend[39;49;00m([96mself[39;49;00m, request, stream=[94mFalse[39;49;00m, timeout=[94mNone[39;49;00m, verify=[94mTrue[39;49;00m, cert=[94mNone[39;49;00m, proxies=[94mNone[39;49;00m):
    [90m    [39;49;00m[33m"""Sends PreparedRequest object. Returns Response object.[39;49;00m
    [33m[39;49;00m
    [33m    :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[39;49;00m
    [33m    :param stream: (optional) Whether to stream the request content.[39;49;00m
    [33m    :param timeout: (optional) How long to wait for the server to send[39;49;00m
    [33m        data before giving up, as a float, or a :ref:`(connect timeout,[39;49;00m
    [33m        read timeout) <timeouts>` tuple.[39;49;00m
    [33m    :type timeout: float or tuple or urllib3 Timeout object[39;49;00m
    [33m    :param verify: (optional) Either a boolean, in which case it controls whether[39;49;00m
    [33m        we verify the server's TLS certificate, or a string, in which case it[39;49;00m
    [33m        must be a path to a CA bundle to use[39;49;00m
    [33m    :param cert: (optional) Any user-provided SSL certificate to be trusted.[39;49;00m
    [33m    :param proxies: (optional) The proxies dictionary to apply to the request.[39;49;00m
    [33m    :rtype: requests.Response[39;49;00m
    [33m    """[39;49;00m
    
        [94mtry[39;49;00m:
            conn = [96mself[39;49;00m.get_connection(request.url, proxies)
        [94mexcept[39;49;00m LocationValueError [94mas[39;49;00m e:
            [94mraise[39;49;00m InvalidURL(e, request=request)
    
        [96mself[39;49;00m.cert_verify(conn, request.url, verify, cert)
        url = [96mself[39;49;00m.request_url(request, proxies)
        [96mself[39;49;00m.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = [95mnot[39;49;00m (request.body [95mis[39;49;00m [94mNone[39;49;00m [95mor[39;49;00m [33m'[39;49;00m[33mContent-Length[39;49;00m[33m'[39;49;00m [95min[39;49;00m request.headers)
    
        [94mif[39;49;00m [96misinstance[39;49;00m(timeout, [96mtuple[39;49;00m):
            [94mtry[39;49;00m:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            [94mexcept[39;49;00m [96mValueError[39;49;00m [94mas[39;49;00m e:
                [90m# this may raise a string formatting error.[39;49;00m
                err = ([33m"[39;49;00m[33mInvalid timeout [39;49;00m[33m{}[39;49;00m[33m. Pass a (connect, read) [39;49;00m[33m"[39;49;00m
                       [33m"[39;49;00m[33mtimeout tuple, or a single float to set [39;49;00m[33m"[39;49;00m
                       [33m"[39;49;00m[33mboth timeouts to the same value[39;49;00m[33m"[39;49;00m.format(timeout))
                [94mraise[39;49;00m [96mValueError[39;49;00m(err)
        [94melif[39;49;00m [96misinstance[39;49;00m(timeout, TimeoutSauce):
            [94mpass[39;49;00m
        [94melse[39;49;00m:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        [94mtry[39;49;00m:
            [94mif[39;49;00m [95mnot[39;49;00m chunked:
>               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=[94mFalse[39;49;00m,
                    assert_same_host=[94mFalse[39;49;00m,
                    preload_content=[94mFalse[39;49;00m,
                    decode_content=[94mFalse[39;49;00m,
                    retries=[96mself[39;49;00m.max_retries,
                    timeout=timeout
                )

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/adapters.py[0m:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fd1506e8c10>
method = 'GET', url = '/api/v2/messages', body = None
headers = {'User-Agent': 'python-requests/2.27.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v2/messages', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    [94mdef[39;49;00m [92murlopen[39;49;00m(
        [96mself[39;49;00m,
        method,
        url,
        body=[94mNone[39;49;00m,
        headers=[94mNone[39;49;00m,
        retries=[94mNone[39;49;00m,
        redirect=[94mTrue[39;49;00m,
        assert_same_host=[94mTrue[39;49;00m,
        timeout=_Default,
        pool_timeout=[94mNone[39;49;00m,
        release_conn=[94mNone[39;49;00m,
        chunked=[94mFalse[39;49;00m,
        body_pos=[94mNone[39;49;00m,
        **response_kw
    ):
    [90m    [39;49;00m[33m"""[39;49;00m
    [33m    Get a connection from the pool and perform an HTTP request. This is the[39;49;00m
    [33m    lowest level call for making a request, so you'll need to specify all[39;49;00m
    [33m    the raw details.[39;49;00m
    [33m[39;49;00m
    [33m    .. note::[39;49;00m
    [33m[39;49;00m
    [33m       More commonly, it's appropriate to use a convenience method provided[39;49;00m
    [33m       by :class:`.RequestMethods`, such as :meth:`request`.[39;49;00m
    [33m[39;49;00m
    [33m    .. note::[39;49;00m
    [33m[39;49;00m
    [33m       `release_conn` will only behave as expected if[39;49;00m
    [33m       `preload_content=False` because we want to make[39;49;00m
    [33m       `preload_content=False` the default behaviour someday soon without[39;49;00m
    [33m       breaking backwards compatibility.[39;49;00m
    [33m[39;49;00m
    [33m    :param method:[39;49;00m
    [33m        HTTP request method (such as GET, POST, PUT, etc.)[39;49;00m
    [33m[39;49;00m
    [33m    :param url:[39;49;00m
    [33m        The URL to perform the request on.[39;49;00m
    [33m[39;49;00m
    [33m    :param body:[39;49;00m
    [33m        Data to send in the request body, either :class:`str`, :class:`bytes`,[39;49;00m
    [33m        an iterable of :class:`str`/:class:`bytes`, or a file-like object.[39;49;00m
    [33m[39;49;00m
    [33m    :param headers:[39;49;00m
    [33m        Dictionary of custom headers to send, such as User-Agent,[39;49;00m
    [33m        If-None-Match, etc. If None, pool headers are used. If provided,[39;49;00m
    [33m        these headers completely replace any pool-specific headers.[39;49;00m
    [33m[39;49;00m
    [33m    :param retries:[39;49;00m
    [33m        Configure the number of retries to allow before raising a[39;49;00m
    [33m        :class:`~urllib3.exceptions.MaxRetryError` exception.[39;49;00m
    [33m[39;49;00m
    [33m        Pass ``None`` to retry until you receive a response. Pass a[39;49;00m
    [33m        :class:`~urllib3.util.retry.Retry` object for fine-grained control[39;49;00m
    [33m        over different types of retries.[39;49;00m
    [33m        Pass an integer number to retry connection errors that many times,[39;49;00m
    [33m        but no other types of errors. Pass zero to never retry.[39;49;00m
    [33m[39;49;00m
    [33m        If ``False``, then retries are disabled and any exception is raised[39;49;00m
    [33m        immediately. Also, instead of raising a MaxRetryError on redirects,[39;49;00m
    [33m        the redirect response will be returned.[39;49;00m
    [33m[39;49;00m
    [33m    :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.[39;49;00m
    [33m[39;49;00m
    [33m    :param redirect:[39;49;00m
    [33m        If True, automatically handle redirects (status codes 301, 302,[39;49;00m
    [33m        303, 307, 308). Each redirect counts as a retry. Disabling retries[39;49;00m
    [33m        will disable redirect, too.[39;49;00m
    [33m[39;49;00m
    [33m    :param assert_same_host:[39;49;00m
    [33m        If ``True``, will make sure that the host of the pool requests is[39;49;00m
    [33m        consistent else will raise HostChangedError. When ``False``, you can[39;49;00m
    [33m        use the pool on an HTTP proxy and request foreign hosts.[39;49;00m
    [33m[39;49;00m
    [33m    :param timeout:[39;49;00m
    [33m        If specified, overrides the default timeout for this one[39;49;00m
    [33m        request. It may be a float (in seconds) or an instance of[39;49;00m
    [33m        :class:`urllib3.util.Timeout`.[39;49;00m
    [33m[39;49;00m
    [33m    :param pool_timeout:[39;49;00m
    [33m        If set and the pool is set to block=True, then this method will[39;49;00m
    [33m        block for ``pool_timeout`` seconds and raise EmptyPoolError if no[39;49;00m
    [33m        connection is available within the time period.[39;49;00m
    [33m[39;49;00m
    [33m    :param release_conn:[39;49;00m
    [33m        If False, then the urlopen call will not release the connection[39;49;00m
    [33m        back into the pool once a response is received (but will release if[39;49;00m
    [33m        you read the entire contents of the response such as when[39;49;00m
    [33m        `preload_content=True`). This is useful if you're not preloading[39;49;00m
    [33m        the response's content immediately. You will need to call[39;49;00m
    [33m        ``r.release_conn()`` on the response ``r`` to return the connection[39;49;00m
    [33m        back into the pool. If None, it takes the value of[39;49;00m
    [33m        ``response_kw.get('preload_content', True)``.[39;49;00m
    [33m[39;49;00m
    [33m    :param chunked:[39;49;00m
    [33m        If True, urllib3 will send the body using chunked transfer[39;49;00m
    [33m        encoding. Otherwise, urllib3 will send the body using the standard[39;49;00m
    [33m        content-length form. Defaults to False.[39;49;00m
    [33m[39;49;00m
    [33m    :param int body_pos:[39;49;00m
    [33m        Position to seek to in file-like body in the event of a retry or[39;49;00m
    [33m        redirect. Typically this won't need to be set because urllib3 will[39;49;00m
    [33m        auto-populate the value when needed.[39;49;00m
    [33m[39;49;00m
    [33m    :param \\**response_kw:[39;49;00m
    [33m        Additional parameters are passed to[39;49;00m
    [33m        :meth:`urllib3.response.HTTPResponse.from_httplib`[39;49;00m
    [33m    """[39;49;00m
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        [94mif[39;49;00m headers [95mis[39;49;00m [94mNone[39;49;00m:
            headers = [96mself[39;49;00m.headers
    
        [94mif[39;49;00m [95mnot[39;49;00m [96misinstance[39;49;00m(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=[96mself[39;49;00m.retries)
    
        [94mif[39;49;00m release_conn [95mis[39;49;00m [94mNone[39;49;00m:
            release_conn = response_kw.get([33m"[39;49;00m[33mpreload_content[39;49;00m[33m"[39;49;00m, [94mTrue[39;49;00m)
    
        [90m# Check host[39;49;00m
        [94mif[39;49;00m assert_same_host [95mand[39;49;00m [95mnot[39;49;00m [96mself[39;49;00m.is_same_host(url):
            [94mraise[39;49;00m HostChangedError([96mself[39;49;00m, url, retries)
    
        [90m# Ensure that the URL we're connecting to is properly encoded[39;49;00m
        [94mif[39;49;00m url.startswith([33m"[39;49;00m[33m/[39;49;00m[33m"[39;49;00m):
            url = six.ensure_str(_encode_target(url))
        [94melse[39;49;00m:
            url = six.ensure_str(parsed_url.url)
    
        conn = [94mNone[39;49;00m
    
        [90m# Track whether `conn` needs to be released before[39;49;00m
        [90m# returning/raising/recursing. Update this variable if necessary, and[39;49;00m
        [90m# leave `release_conn` constant throughout the function. That way, if[39;49;00m
        [90m# the function recurses, the original value of `release_conn` will be[39;49;00m
        [90m# passed down into the recursive call, and its value will be respected.[39;49;00m
        [90m#[39;49;00m
        [90m# See issue #651 [1] for details.[39;49;00m
        [90m#[39;49;00m
        [90m# [1] <https://github.com/urllib3/urllib3/issues/651>[39;49;00m
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            [96mself[39;49;00m.proxy, [96mself[39;49;00m.proxy_config, destination_scheme
        )
    
        [90m# Merge the proxy headers. Only done when not using HTTP CONNECT. We[39;49;00m
        [90m# have to copy the headers dict so we can safely change it without those[39;49;00m
        [90m# changes being reflected in anyone else's copy.[39;49;00m
        [94mif[39;49;00m [95mnot[39;49;00m http_tunnel_required:
            headers = headers.copy()
            headers.update([96mself[39;49;00m.proxy_headers)
    
        [90m# Must keep the exception bound to a separate variable or else Python 3[39;49;00m
        [90m# complains about UnboundLocalError.[39;49;00m
        err = [94mNone[39;49;00m
    
        [90m# Keep track of whether we cleanly exited the except block. This[39;49;00m
        [90m# ensures we do proper cleanup in finally.[39;49;00m
        clean_exit = [94mFalse[39;49;00m
    
        [90m# Rewind body position, if needed. Record current position[39;49;00m
        [90m# for future rewinds in the event of a redirect/retry.[39;49;00m
        body_pos = set_file_position(body, body_pos)
    
        [94mtry[39;49;00m:
            [90m# Request a connection from the queue.[39;49;00m
            timeout_obj = [96mself[39;49;00m._get_timeout(timeout)
            conn = [96mself[39;49;00m._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = [96mself[39;49;00m.proxy [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m [95mand[39;49;00m [95mnot[39;49;00m [96mgetattr[39;49;00m(
                conn, [33m"[39;49;00m[33msock[39;49;00m[33m"[39;49;00m, [94mNone[39;49;00m
            )
            [94mif[39;49;00m is_new_proxy_conn [95mand[39;49;00m http_tunnel_required:
                [96mself[39;49;00m._prepare_proxy(conn)
    
            [90m# Make the request on the httplib connection object.[39;49;00m
            httplib_response = [96mself[39;49;00m._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            [90m# If we're going to release the connection in ``finally:``, then[39;49;00m
            [90m# the response doesn't need to know about the connection. Otherwise[39;49;00m
            [90m# it will also try to release it and we'll have a double-release[39;49;00m
            [90m# mess.[39;49;00m
            response_conn = conn [94mif[39;49;00m [95mnot[39;49;00m release_conn [94melse[39;49;00m [94mNone[39;49;00m
    
            [90m# Pass method to Response for length checking[39;49;00m
            response_kw[[33m"[39;49;00m[33mrequest_method[39;49;00m[33m"[39;49;00m] = method
    
            [90m# Import httplib's response into our own wrapper object[39;49;00m
            response = [96mself[39;49;00m.ResponseCls.from_httplib(
                httplib_response,
                pool=[96mself[39;49;00m,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            [90m# Everything went great![39;49;00m
            clean_exit = [94mTrue[39;49;00m
    
        [94mexcept[39;49;00m EmptyPoolError:
            [90m# Didn't get a connection from the pool, no need to clean up[39;49;00m
            clean_exit = [94mTrue[39;49;00m
            release_this_conn = [94mFalse[39;49;00m
            [94mraise[39;49;00m
    
        [94mexcept[39;49;00m (
            [96mTimeoutError[39;49;00m,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) [94mas[39;49;00m e:
            [90m# Discard the connection for these exceptions. It will be[39;49;00m
            [90m# replaced during the next _get_conn() call.[39;49;00m
            clean_exit = [94mFalse[39;49;00m
    
            [94mdef[39;49;00m [92m_is_ssl_error_message_from_http_proxy[39;49;00m(ssl_error):
                [90m# We're trying to detect the message 'WRONG_VERSION_NUMBER' but[39;49;00m
                [90m# SSLErrors are kinda all over the place when it comes to the message,[39;49;00m
                [90m# so we try to cover our bases here![39;49;00m
                message = [33m"[39;49;00m[33m [39;49;00m[33m"[39;49;00m.join(re.split([33m"[39;49;00m[33m[^a-z][39;49;00m[33m"[39;49;00m, [96mstr[39;49;00m(ssl_error).lower()))
                [94mreturn[39;49;00m (
                    [33m"[39;49;00m[33mwrong version number[39;49;00m[33m"[39;49;00m [95min[39;49;00m message [95mor[39;49;00m [33m"[39;49;00m[33munknown protocol[39;49;00m[33m"[39;49;00m [95min[39;49;00m message
                )
    
            [90m# Try to detect a common user error with proxies which is to[39;49;00m
            [90m# set an HTTP proxy to be HTTPS when it should be 'http://'[39;49;00m
            [90m# (ie {'http': 'http://proxy', 'https': 'https://proxy'})[39;49;00m
            [90m# Instead we add a nice error message and point to a URL.[39;49;00m
            [94mif[39;49;00m (
                [96misinstance[39;49;00m(e, BaseSSLError)
                [95mand[39;49;00m [96mself[39;49;00m.proxy
                [95mand[39;49;00m _is_ssl_error_message_from_http_proxy(e)
            ):
                e = ProxyError(
                    [33m"[39;49;00m[33mYour proxy appears to only use HTTP and not HTTPS, [39;49;00m[33m"[39;49;00m
                    [33m"[39;49;00m[33mtry changing your proxy URL to be HTTP. See: [39;49;00m[33m"[39;49;00m
                    [33m"[39;49;00m[33mhttps://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html[39;49;00m[33m"[39;49;00m
                    [33m"[39;49;00m[33m#https-proxy-error-http-proxy[39;49;00m[33m"[39;49;00m,
                    SSLError(e),
                )
            [94melif[39;49;00m [96misinstance[39;49;00m(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            [94melif[39;49;00m [96misinstance[39;49;00m(e, (SocketError, NewConnectionError)) [95mand[39;49;00m [96mself[39;49;00m.proxy:
                e = ProxyError([33m"[39;49;00m[33mCannot connect to proxy.[39;49;00m[33m"[39;49;00m, e)
            [94melif[39;49;00m [96misinstance[39;49;00m(e, (SocketError, HTTPException)):
                e = ProtocolError([33m"[39;49;00m[33mConnection aborted.[39;49;00m[33m"[39;49;00m, e)
    
>           retries = retries.increment(
                method, url, error=e, _pool=[96mself[39;49;00m, _stacktrace=sys.exc_info()[[94m2[39;49;00m]
            )

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/connectionpool.py[0m:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v2/messages', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>: Failed to establish a new connection: [Errno 111] Connection refused')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fd1506e8c10>
_stacktrace = <traceback object at 0x7fd15087bac0>

    [94mdef[39;49;00m [92mincrement[39;49;00m(
        [96mself[39;49;00m,
        method=[94mNone[39;49;00m,
        url=[94mNone[39;49;00m,
        response=[94mNone[39;49;00m,
        error=[94mNone[39;49;00m,
        _pool=[94mNone[39;49;00m,
        _stacktrace=[94mNone[39;49;00m,
    ):
    [90m    [39;49;00m[33m"""Return a new Retry object with incremented retry counters.[39;49;00m
    [33m[39;49;00m
    [33m    :param response: A response object, or None, if the server did not[39;49;00m
    [33m        return a response.[39;49;00m
    [33m    :type response: :class:`~urllib3.response.HTTPResponse`[39;49;00m
    [33m    :param Exception error: An error encountered during the request, or[39;49;00m
    [33m        None if the response was received successfully.[39;49;00m
    [33m[39;49;00m
    [33m    :return: A new ``Retry`` object.[39;49;00m
    [33m    """[39;49;00m
        [94mif[39;49;00m [96mself[39;49;00m.total [95mis[39;49;00m [94mFalse[39;49;00m [95mand[39;49;00m error:
            [90m# Disabled, indicate to re-raise the error.[39;49;00m
            [94mraise[39;49;00m six.reraise([96mtype[39;49;00m(error), error, _stacktrace)
    
        total = [96mself[39;49;00m.total
        [94mif[39;49;00m total [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
            total -= [94m1[39;49;00m
    
        connect = [96mself[39;49;00m.connect
        read = [96mself[39;49;00m.read
        redirect = [96mself[39;49;00m.redirect
        status_count = [96mself[39;49;00m.status
        other = [96mself[39;49;00m.other
        cause = [33m"[39;49;00m[33munknown[39;49;00m[33m"[39;49;00m
        status = [94mNone[39;49;00m
        redirect_location = [94mNone[39;49;00m
    
        [94mif[39;49;00m error [95mand[39;49;00m [96mself[39;49;00m._is_connection_error(error):
            [90m# Connect retry?[39;49;00m
            [94mif[39;49;00m connect [95mis[39;49;00m [94mFalse[39;49;00m:
                [94mraise[39;49;00m six.reraise([96mtype[39;49;00m(error), error, _stacktrace)
            [94melif[39;49;00m connect [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                connect -= [94m1[39;49;00m
    
        [94melif[39;49;00m error [95mand[39;49;00m [96mself[39;49;00m._is_read_error(error):
            [90m# Read retry?[39;49;00m
            [94mif[39;49;00m read [95mis[39;49;00m [94mFalse[39;49;00m [95mor[39;49;00m [95mnot[39;49;00m [96mself[39;49;00m._is_method_retryable(method):
                [94mraise[39;49;00m six.reraise([96mtype[39;49;00m(error), error, _stacktrace)
            [94melif[39;49;00m read [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                read -= [94m1[39;49;00m
    
        [94melif[39;49;00m error:
            [90m# Other retry?[39;49;00m
            [94mif[39;49;00m other [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                other -= [94m1[39;49;00m
    
        [94melif[39;49;00m response [95mand[39;49;00m response.get_redirect_location():
            [90m# Redirect retry?[39;49;00m
            [94mif[39;49;00m redirect [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                redirect -= [94m1[39;49;00m
            cause = [33m"[39;49;00m[33mtoo many redirects[39;49;00m[33m"[39;49;00m
            redirect_location = response.get_redirect_location()
            status = response.status
    
        [94melse[39;49;00m:
            [90m# Incrementing because of a server error like a 500 in[39;49;00m
            [90m# status_forcelist and the given method is in the allowed_methods[39;49;00m
            cause = ResponseError.GENERIC_ERROR
            [94mif[39;49;00m response [95mand[39;49;00m response.status:
                [94mif[39;49;00m status_count [95mis[39;49;00m [95mnot[39;49;00m [94mNone[39;49;00m:
                    status_count -= [94m1[39;49;00m
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = [96mself[39;49;00m.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = [96mself[39;49;00m.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        [94mif[39;49;00m new_retry.is_exhausted():
>           [94mraise[39;49;00m MaxRetryError(_pool, url, error [95mor[39;49;00m ResponseError(cause))
[1m[31mE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=8025): Max retries exceeded with url: /api/v2/messages (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>: Failed to establish a new connection: [Errno 111] Connection refused'))[0m

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/urllib3/util/retry.py[0m:592: MaxRetryError

[33mDuring handling of the above exception, another exception occurred:[0m

client = <starlette.testclient.TestClient object at 0x7fd152686ef0>

    [94mdef[39;49;00m [92mtest_reset_password[39;49;00m(client: TestClient) -> [94mNone[39;49;00m:
    
>       mailhog_email_req = requests.get([33mf[39;49;00m[33m"[39;49;00m[33m{[39;49;00mMAILHOG_URL[33m}[39;49;00m[33m/v2/messages[39;49;00m[33m"[39;49;00m)

[1m[31mtests/api/api_v1/test_auth.py[0m:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/api.py[0m:75: in get
    [94mreturn[39;49;00m request([33m'[39;49;00m[33mget[39;49;00m[33m'[39;49;00m, url, params=params, **kwargs)
[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/api.py[0m:61: in request
    [94mreturn[39;49;00m session.request(method=method, url=url, **kwargs)
[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/sessions.py[0m:529: in request
    resp = [96mself[39;49;00m.send(prep, **send_kwargs)
[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/sessions.py[0m:645: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7fd1506ea230>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    [94mdef[39;49;00m [92msend[39;49;00m([96mself[39;49;00m, request, stream=[94mFalse[39;49;00m, timeout=[94mNone[39;49;00m, verify=[94mTrue[39;49;00m, cert=[94mNone[39;49;00m, proxies=[94mNone[39;49;00m):
    [90m    [39;49;00m[33m"""Sends PreparedRequest object. Returns Response object.[39;49;00m
    [33m[39;49;00m
    [33m    :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[39;49;00m
    [33m    :param stream: (optional) Whether to stream the request content.[39;49;00m
    [33m    :param timeout: (optional) How long to wait for the server to send[39;49;00m
    [33m        data before giving up, as a float, or a :ref:`(connect timeout,[39;49;00m
    [33m        read timeout) <timeouts>` tuple.[39;49;00m
    [33m    :type timeout: float or tuple or urllib3 Timeout object[39;49;00m
    [33m    :param verify: (optional) Either a boolean, in which case it controls whether[39;49;00m
    [33m        we verify the server's TLS certificate, or a string, in which case it[39;49;00m
    [33m        must be a path to a CA bundle to use[39;49;00m
    [33m    :param cert: (optional) Any user-provided SSL certificate to be trusted.[39;49;00m
    [33m    :param proxies: (optional) The proxies dictionary to apply to the request.[39;49;00m
    [33m    :rtype: requests.Response[39;49;00m
    [33m    """[39;49;00m
    
        [94mtry[39;49;00m:
            conn = [96mself[39;49;00m.get_connection(request.url, proxies)
        [94mexcept[39;49;00m LocationValueError [94mas[39;49;00m e:
            [94mraise[39;49;00m InvalidURL(e, request=request)
    
        [96mself[39;49;00m.cert_verify(conn, request.url, verify, cert)
        url = [96mself[39;49;00m.request_url(request, proxies)
        [96mself[39;49;00m.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = [95mnot[39;49;00m (request.body [95mis[39;49;00m [94mNone[39;49;00m [95mor[39;49;00m [33m'[39;49;00m[33mContent-Length[39;49;00m[33m'[39;49;00m [95min[39;49;00m request.headers)
    
        [94mif[39;49;00m [96misinstance[39;49;00m(timeout, [96mtuple[39;49;00m):
            [94mtry[39;49;00m:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            [94mexcept[39;49;00m [96mValueError[39;49;00m [94mas[39;49;00m e:
                [90m# this may raise a string formatting error.[39;49;00m
                err = ([33m"[39;49;00m[33mInvalid timeout [39;49;00m[33m{}[39;49;00m[33m. Pass a (connect, read) [39;49;00m[33m"[39;49;00m
                       [33m"[39;49;00m[33mtimeout tuple, or a single float to set [39;49;00m[33m"[39;49;00m
                       [33m"[39;49;00m[33mboth timeouts to the same value[39;49;00m[33m"[39;49;00m.format(timeout))
                [94mraise[39;49;00m [96mValueError[39;49;00m(err)
        [94melif[39;49;00m [96misinstance[39;49;00m(timeout, TimeoutSauce):
            [94mpass[39;49;00m
        [94melse[39;49;00m:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        [94mtry[39;49;00m:
            [94mif[39;49;00m [95mnot[39;49;00m chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=[94mFalse[39;49;00m,
                    assert_same_host=[94mFalse[39;49;00m,
                    preload_content=[94mFalse[39;49;00m,
                    decode_content=[94mFalse[39;49;00m,
                    retries=[96mself[39;49;00m.max_retries,
                    timeout=timeout
                )
    
            [90m# Send the request.[39;49;00m
            [94melse[39;49;00m:
                [94mif[39;49;00m [96mhasattr[39;49;00m(conn, [33m'[39;49;00m[33mproxy_pool[39;49;00m[33m'[39;49;00m):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                [94mtry[39;49;00m:
                    skip_host = [33m'[39;49;00m[33mHost[39;49;00m[33m'[39;49;00m [95min[39;49;00m request.headers
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=[94mTrue[39;49;00m,
                                        skip_host=skip_host)
    
                    [94mfor[39;49;00m header, value [95min[39;49;00m request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    [94mfor[39;49;00m i [95min[39;49;00m request.body:
                        low_conn.send([96mhex[39;49;00m([96mlen[39;49;00m(i))[[94m2[39;49;00m:].encode([33m'[39;49;00m[33mutf-8[39;49;00m[33m'[39;49;00m))
                        low_conn.send([33mb[39;49;00m[33m'[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m'[39;49;00m)
                        low_conn.send(i)
                        low_conn.send([33mb[39;49;00m[33m'[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m'[39;49;00m)
                    low_conn.send([33mb[39;49;00m[33m'[39;49;00m[33m0[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m\r[39;49;00m[33m\n[39;49;00m[33m'[39;49;00m)
    
                    [90m# Receive the response from the server[39;49;00m
                    [94mtry[39;49;00m:
                        [90m# For Python 2.7, use buffering of HTTP responses[39;49;00m
                        r = low_conn.getresponse(buffering=[94mTrue[39;49;00m)
                    [94mexcept[39;49;00m [96mTypeError[39;49;00m:
                        [90m# For compatibility with Python 3.3+[39;49;00m
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=[94mFalse[39;49;00m,
                        decode_content=[94mFalse[39;49;00m
                    )
                [94mexcept[39;49;00m:
                    [90m# If we hit any problems here, clean up the connection.[39;49;00m
                    [90m# Then, reraise so that we can handle the actual exception.[39;49;00m
                    low_conn.close()
                    [94mraise[39;49;00m
    
        [94mexcept[39;49;00m (ProtocolError, socket.error) [94mas[39;49;00m err:
            [94mraise[39;49;00m [96mConnectionError[39;49;00m(err, request=request)
    
        [94mexcept[39;49;00m MaxRetryError [94mas[39;49;00m e:
            [94mif[39;49;00m [96misinstance[39;49;00m(e.reason, ConnectTimeoutError):
                [90m# TODO: Remove this in 3.0.0: see #2811[39;49;00m
                [94mif[39;49;00m [95mnot[39;49;00m [96misinstance[39;49;00m(e.reason, NewConnectionError):
                    [94mraise[39;49;00m ConnectTimeout(e, request=request)
    
            [94mif[39;49;00m [96misinstance[39;49;00m(e.reason, ResponseError):
                [94mraise[39;49;00m RetryError(e, request=request)
    
            [94mif[39;49;00m [96misinstance[39;49;00m(e.reason, _ProxyError):
                [94mraise[39;49;00m ProxyError(e, request=request)
    
            [94mif[39;49;00m [96misinstance[39;49;00m(e.reason, _SSLError):
                [90m# This branch is for urllib3 v1.22 and later.[39;49;00m
                [94mraise[39;49;00m SSLError(e, request=request)
    
>           [94mraise[39;49;00m [96mConnectionError[39;49;00m(e, request=request)
[1m[31mE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=8025): Max retries exceeded with url: /api/v2/messages (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fd1509f5ab0>: Failed to establish a new connection: [Errno 111] Connection refused'))[0m

[1m[31m/opt/python/3.10.8/lib/python3.10/site-packages/requests/adapters.py[0m:519: ConnectionError
[31m[1m_________________________ test_login_with_new_password _________________________[0m

client = <starlette.testclient.TestClient object at 0x7fd152686ef0>

    [94mdef[39;49;00m [92mtest_login_with_new_password[39;49;00m(client: TestClient):
        data = {
            [33m"[39;49;00m[33musername[39;49;00m[33m"[39;49;00m: [33m"[39;49;00m[33mtest_student@test.local[39;49;00m[33m"[39;49;00m,
            [33m"[39;49;00m[33mpassword[39;49;00m[33m"[39;49;00m: [33m"[39;49;00m[33mtest[39;49;00m[33m"[39;49;00m,
            [33m"[39;49;00m[33mremember_me[39;49;00m[33m"[39;49;00m: [94mTrue[39;49;00m,
        }
    
        req = client.post(
            [33mf[39;49;00m[33m"[39;49;00m[33m{[39;49;00msettings.BACKEND_URL_BASE[33m}[39;49;00m[33m{[39;49;00msettings.API_V1_STR[33m}[39;49;00m[33m/auth/web/[39;49;00m[33m"[39;49;00m,
            json=data,
            headers=headers,
        )
    
>       [94massert[39;49;00m req.status_code == [94m200[39;49;00m, [33m"[39;49;00m[33mCouldn[39;49;00m[33m'[39;49;00m[33mt login with new password[39;49;00m[33m"[39;49;00m
[1m[31mE       AssertionError: Couldn't login with new password[0m
[1m[31mE       assert 401 == 200[0m
[1m[31mE         +401[0m
[1m[31mE         -200[0m

[1m[31mtests/api/api_v1/test_auth.py[0m:196: AssertionError
[31m[1m_____________________________ test_change_password _____________________________[0m

client = <starlette.testclient.TestClient object at 0x7fd152686ef0>

    [94mdef[39;49;00m [92mtest_change_password[39;49;00m(client: TestClient):
        wrong_data = {
            [33m"[39;49;00m[33mcurrent_password[39;49;00m[33m"[39;49;00m: [33m"[39;49;00m[33mtestwrong[39;49;00m[33m"[39;49;00m,
            [33m"[39;49;00m[33mnew_password[39;49;00m[33m"[39;49;00m: [33m"[39;49;00m[33mnewtest[39;49;00m[33m"[39;49;00m,
        }
    
        req = client.post(
            [33mf[39;49;00m[33m"[39;49;00m[33m{[39;49;00msettings.BACKEND_URL_BASE[33m}[39;49;00m[33m{[39;49;00msettings.API_V1_STR[33m}[39;49;00m[33m/auth/change-password/[39;49;00m[33m"[39;49;00m,
            json=wrong_data,
            headers=headers,
        )
    
        [94massert[39;49;00m req.status_code != [94m200[39;49;00m
    
        data = {
            [33m"[39;49;00m[33mcurrent_password[39;49;00m[33m"[39;49;00m: [33m"[39;49;00m[33mtest[39;49;00m[33m"[39;49;00m,
            [33m"[39;49;00m[33mnew_password[39;49;00m[33m"[39;49;00m: [33m"[39;49;00m[33mnewtest[39;49;00m[33m"[39;49;00m,
        }
    
        req = client.post(
            [33mf[39;49;00m[33m"[39;49;00m[33m{[39;49;00msettings.BACKEND_URL_BASE[33m}[39;49;00m[33m{[39;49;00msettings.API_V1_STR[33m}[39;49;00m[33m/auth/change-password/[39;49;00m[33m"[39;49;00m,
            json=data,
            headers=headers,
        )
    
>       [94massert[39;49;00m req.status_code == [94m200[39;49;00m
[1m[31mE       assert 403 == 200[0m
[1m[31mE         +403[0m
[1m[31mE         -200[0m

[1m[31mtests/api/api_v1/test_auth.py[0m:225: AssertionError
[31m[1m_________________________________ test_logout __________________________________[0m

client = <starlette.testclient.TestClient object at 0x7fd152686ef0>

    [94mdef[39;49;00m [92mtest_logout[39;49;00m(client: TestClient) -> [94mNone[39;49;00m:
        response = client.get(
            [33mf[39;49;00m[33m"[39;49;00m[33m{[39;49;00msettings.BACKEND_URL_BASE[33m}[39;49;00m[33m{[39;49;00msettings.API_V1_STR[33m}[39;49;00m[33m/auth/logout/[39;49;00m[33m"[39;49;00m,
            headers=headers,
        )
    
>       [94massert[39;49;00m response.status_code == [94m200[39;49;00m
[1m[31mE       assert 401 == 200[0m
[1m[31mE         +401[0m
[1m[31mE         -200[0m

[1m[31mtests/api/api_v1/test_auth.py[0m:241: AssertionError
[31m[1m_______________________________ test_delete_user _______________________________[0m

db = <sqlalchemy.orm.session.Session object at 0x7fd150931d20>
super_user_client = <starlette.testclient.TestClient object at 0x7fd150931a80>

    [94mdef[39;49;00m [92mtest_delete_user[39;49;00m(db, super_user_client: TestClient):
        data = {
            [33m"[39;49;00m[33musername[39;49;00m[33m"[39;49;00m: [33m"[39;49;00m[33mtest_superadmin@test.local[39;49;00m[33m"[39;49;00m,
            [33m"[39;49;00m[33mpassword[39;49;00m[33m"[39;49;00m: [33m"[39;49;00m[33mtest[39;49;00m[33m"[39;49;00m,
            [33m"[39;49;00m[33mremember_me[39;49;00m[33m"[39;49;00m: [94mFalse[39;49;00m,
        }
    
        req = super_user_client.post(
            [33mf[39;49;00m[33m"[39;49;00m[33m{[39;49;00msettings.BACKEND_URL_BASE[33m}[39;49;00m[33m{[39;49;00msettings.API_V1_STR[33m}[39;49;00m[33m/auth/web/[39;49;00m[33m"[39;49;00m,
            json=data,
            headers=headers,
        )
    
        [94massert[39;49;00m req.status_code == [94m200[39;49;00m, [33m"[39;49;00m[33mSuperadmin login failed[39;49;00m[33m"[39;49;00m
        [94massert[39;49;00m req.cookies.get([33m"[39;49;00m[33msession[39;49;00m[33m"[39;49;00m), [33m"[39;49;00m[33mSuperadmin cookie not returned![39;49;00m[33m"[39;49;00m
    
        user = crud_user.get_by_email(db, email=[33m"[39;49;00m[33mtest_student@test.local[39;49;00m[33m"[39;49;00m)
    
        delete_req = super_user_client.delete(
>           [33mf[39;49;00m[33m"[39;49;00m[33m{[39;49;00msettings.BACKEND_URL_BASE[33m}[39;49;00m[33m{[39;49;00msettings.API_V1_STR[33m}[39;49;00m[33m/users/[39;49;00m[33m{[39;49;00muser.id[33m}[39;49;00m[33m/[39;49;00m[33m"[39;49;00m,
        )
[1m[31mE       AttributeError: 'NoneType' object has no attribute 'id'[0m

[1m[31mtests/api/api_v1/test_auth.py[0m:263: AttributeError
=========================== short test summary info ============================
FAILED tests/api/api_v1/test_auth.py::test_signup - requests.exceptions.Conne...
FAILED tests/api/api_v1/test_auth.py::test_verification_email - requests.exce...
FAILED tests/api/api_v1/test_auth.py::test_web_session_authentication - asser...
FAILED tests/api/api_v1/test_auth.py::test_send_reset_email - assert 404 == 200
FAILED tests/api/api_v1/test_auth.py::test_reset_password - requests.exceptio...
FAILED tests/api/api_v1/test_auth.py::test_login_with_new_password - Assertio...
FAILED tests/api/api_v1/test_auth.py::test_change_password - assert 403 == 200
FAILED tests/api/api_v1/test_auth.py::test_logout - assert 401 == 200
FAILED tests/api/api_v1/test_auth.py::test_delete_user - AttributeError: 'Non...
[31m========================= [31m[1m9 failed[0m, [32m22 passed[0m[31m in 2.30s[0m[31m =========================[0m
